import 'dart:async'; // StreamSubscription用
import 'package:dio/dio.dart'; // CancelToken用
import 'package:flutter/foundation.dart'; // for debugPrint
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:frontend/features/settings/providers/settings_provider.dart';
import 'package:frontend/core/models/alert_model.dart';
// Removed duplicate: chat_message_model.dart - using chat_message.dart instead
import 'package:frontend/core/models/timeline_item_model.dart';
import 'package:frontend/core/providers/service_providers.dart';
import 'package:frontend/core/services/api_service.dart'; // Import ApiService
import 'package:frontend/features/main_timeline/providers/device_status_provider.dart';
import 'package:frontend/core/models/chat_message.dart'; // For ChatMessage and MessageSender
import 'package:riverpod_annotation/riverpod_annotation.dart'; // For @Riverpod
import 'package:tuple/tuple.dart'; // For Tuple2
import 'package:google_maps_flutter/google_maps_flutter.dart'; // For LatLng
import 'package:frontend/core/services/timeline_storage_service.dart';
import 'package:frontend/core/models/location_model.dart';
import 'package:shared_preferences/shared_preferences.dart';

part 'timeline_provider.freezed.dart';
part 'timeline_provider.g.dart';

enum TimelineScrollBehavior {
  none,           // スクロールしない
  toBottom,       // 最下部へ（チャット質問時）
  toResponse,     // 特定の回答へ（カードクリック時）
  toAlert,        // 災害アラートへ（アラート受信時）
}

@freezed
class TimelineState with _$TimelineState {
  const factory TimelineState({
    @Default(<TimelineItemModel>[]) List<TimelineItemModel> timelineItems,
    @Default(false) bool isLoading,
    @Default(false) bool isChatLoading, // チャット送信時のローディング専用
    @Default(false) bool isEmergencyLoading, // 緊急モード切り替え時のローディング専用
    @Default(true) bool hasMoreItems,
    String? errorMessage,
    AlertModel? importantAlert,
    @Default('') String currentChatInput,
    @Default(true) bool isStreamingEnabled, // ストリーミング機能の有効/無効
    @Default(false) bool isStreaming, // 現在ストリーミング中かどうか
    @Default(<TimelineItemModel>[]) List<TimelineItemModel> streamedSuggestions, // ストリーミング中の提案
    @Default({}) Map<String, Map<String, dynamic>> shelterDataCache, // 避難所データのキャッシュ
    @Default({}) Map<String, String> chatIdToShelterDataId, // チャットIDから避難所データIDへのマッピング
    @Default('') String chatLoadingStatus, // 詳細なチャットローディング状態
    @Default(TimelineScrollBehavior.none) TimelineScrollBehavior scrollBehavior, // スクロール動作制御
    String? targetResponseId, // スクロール先の回答ID
    String? targetAlertId, // スクロール先のアラートID
    CancelToken? chatCancelToken, // チャット中止用トークン
  }) = _TimelineState;
}

@Riverpod(keepAlive: true)
class Timeline extends _$Timeline {
  // Extends _$Timeline (generated by Riverpod Generator)
  StreamSubscription? _streamSubscription;
  Timer? _saveDebounceTimer;
  bool _isDisposed = false;
  bool _isLoadingSavedTimeline = false;
  
  @override
  TimelineState build() {
    // This is the initial state
    debugPrint('[TimelineProvider] build() called, starting with isLoading: true');
    
    // ホットリロード対策: 保存データから復元を試みる
    Future.microtask(() async {
      try {
        final savedItems = await TimelineStorageService.loadTimelineItems();
        final savedShelterCache = await TimelineStorageService.loadShelterDataCache();
        final savedChatToShelterMapping = await TimelineStorageService.loadChatToShelterMapping();
        
        if (savedItems.isNotEmpty && !_isDisposed) {
          // 保存されたデータがある場合は即座に復元（ローディング表示なし）
          state = state.copyWith(
            timelineItems: savedItems,
            shelterDataCache: savedShelterCache,
            chatIdToShelterDataId: savedChatToShelterMapping,
            isLoading: false,
          );
        } else {
          // 保存データがない場合は通常の初期化
          _loadSavedTimeline();
        }
      } catch (e) {
        debugPrint('[TimelineProvider] Error in hot reload recovery: $e');
        _loadSavedTimeline();
      }
    });
    
    // 設定が読み込まれてからタイムライン取得を実行
    ref.listen(settingsProvider, (previous, next) {
      // Check for language change specifically
      final previousLanguage = previous?.currentUserSettings?.languageCode;
      final nextLanguage = next.currentUserSettings?.languageCode;
      final languageChanged =
          previousLanguage != nextLanguage && nextLanguage != null;

      // 言語が変更された場合は強制リフレッシュ
      if (next.currentUserSettings != null && !next.isLoading) {
        if (languageChanged && !state.isLoading) {
          // 言語変更時はforceRefreshForLanguageChangeを呼び出す
          Future.microtask(() => forceRefreshForLanguageChange());
        }
      }
    });

    return const TimelineState(
      isStreamingEnabled: true, // SSEをデフォルト有効化
      isLoading: true, // Show loading animation on startup
    ); // Return the initial state
  }

  // Helper to access ApiService
  ApiService get _apiService => ref.read(apiServiceProvider);

  /// 保存されたタイムラインを読み込む
  Future<void> _loadSavedTimeline() async {
    // Prevent multiple simultaneous loads
    if (_isLoadingSavedTimeline) {
      print('[TimelineProvider] Already loading saved timeline, skipping');
      return;
    }
    
    _isLoadingSavedTimeline = true;
    
    try {
      print('[TimelineProvider] Starting _loadSavedTimeline, isLoading: ${state.isLoading}');
      
      // Start a timer to ensure minimum loading duration (2 seconds for better visibility)
      final minimumLoadingFuture = Future.delayed(const Duration(milliseconds: 2000));
      
      // Uncomment the following line to test loading animation
      // await TimelineStorageService.clearAllData();
      
      final savedItems = await TimelineStorageService.loadTimelineItems();
      final savedShelterCache = await TimelineStorageService.loadShelterDataCache();
      final savedChatToShelterMapping = await TimelineStorageService.loadChatToShelterMapping();
      
      // Wait for minimum loading duration to complete
      await minimumLoadingFuture;
      
      print('[TimelineProvider] Minimum loading duration complete, isLoading: ${state.isLoading}');
      
      // Check if the provider is still active before updating state
      if (_isDisposed) {
        print('[TimelineProvider] Provider disposed, not updating state');
        return;
      }
      
      if (savedItems.isNotEmpty) {
        // 古いアイテムをクリーンアップ
        final cleanedItems = await TimelineStorageService.cleanupOldItems(savedItems);
        
        if (cleanedItems.isNotEmpty) {
          state = state.copyWith(
            timelineItems: cleanedItems,
            shelterDataCache: savedShelterCache,
            chatIdToShelterDataId: savedChatToShelterMapping,
            isLoading: false, // Turn off loading after loading saved items
          );
        } else {
          // All items were cleaned up, just turn off loading
          state = state.copyWith(isLoading: false);
        }
      } else if (savedShelterCache.isNotEmpty || savedChatToShelterMapping.isNotEmpty) {
        // タイムラインアイテムがなくても避難所データがある場合は復元
        state = state.copyWith(
          shelterDataCache: savedShelterCache,
          chatIdToShelterDataId: savedChatToShelterMapping,
          isLoading: false, // Turn off loading even when no timeline items
        );
      } else {
        // No saved data at all, just turn off loading
        debugPrint('[TimelineProvider] No saved data, setting isLoading to false');
        state = state.copyWith(isLoading: false);
      }
    } catch (e) {
      debugPrint('[TimelineProvider] Error loading saved timeline: $e');
      // Also turn off loading on error
      state = state.copyWith(isLoading: false);
    } finally {
      _isLoadingSavedTimeline = false;
    }
  }

  /// タイムラインアイテムを保存（デバウンス付き）
  void _saveTimeline() {
    // 既存のタイマーをキャンセル
    _saveDebounceTimer?.cancel();
    
    // 300ms後に保存実行（デバウンス）
    _saveDebounceTimer = Timer(const Duration(milliseconds: 300), () {
      _executeSave();
    });
  }

  /// 即座にタイムラインを保存（デバウンスなし）
  void _saveTimelineImmediate() {
    _saveDebounceTimer?.cancel();
    _executeSave();
  }

  /// 実際の保存処理
  void _executeSave() {
    try {
      // 非同期で保存（UIをブロックしない）
      Future.microtask(() async {
        await TimelineStorageService.saveTimelineItems(state.timelineItems);
        await TimelineStorageService.saveShelterDataCache(state.shelterDataCache);
        await TimelineStorageService.saveChatToShelterMapping(state.chatIdToShelterDataId);
      }).catchError((e) {
      // debugPrint('[TimelineProvider] Error saving timeline: $e');
      });
    } catch (e) {
      // debugPrint('[TimelineProvider] Error initiating timeline save: $e');
    }
  }

  /// 手動でタイムライン取得をトリガー
  Future<void> refreshTimeline() async {
    // タイムラインのリフレッシュはDeviceStatusProviderのハートビートで処理される
    try {
      if (ref.exists(deviceStatusProvider)) {
        await ref.read(deviceStatusProvider.notifier).sendImmediateHeartbeat();
      }
    } catch (e) {
      // debugPrint('[TimelineProvider] Failed to trigger immediate heartbeat: $e');
    }
  }

  /// タイムラインアイテムを追加
  void addTimelineItem(TimelineItemModel item) {
    if (kDebugMode) {
      print('[TimelineProvider] Adding item: ${item.id}, type: ${item.type}');
      print('[TimelineProvider] Total items before: ${state.timelineItems.length}');
    }
    
    state = state.copyWith(
      timelineItems: [...state.timelineItems, item],
      scrollBehavior: TimelineScrollBehavior.toBottom,
    );
    
    if (kDebugMode) {
      print('[TimelineProvider] Total items after: ${state.timelineItems.length}');
    }
    
    _saveTimeline();
  }

  /// 言語設定変更時にタイムラインを強制リフレッシュ
  Future<void> forceRefreshForLanguageChange() async {
    // Clear current timeline first
    state = state.copyWith(timelineItems: [], errorMessage: null);

    // DeviceStatusProviderに即座にハートビート送信を要求
    try {
      if (ref.exists(deviceStatusProvider)) {
        await ref.read(deviceStatusProvider.notifier).sendImmediateHeartbeat();
      }
    } catch (e) {
      // debugPrint('[TimelineProvider] Failed to send immediate heartbeat: $e');
    }
  }


  Future<void> fetchMoreItems() async {
    if (state.isLoading || !state.hasMoreItems) return;

    state = state.copyWith(isLoading: true);
    try {
      String? actualLastItemId;
      if (state.timelineItems.isNotEmpty) {
        // Accessing the wrapped data correctly for id
        actualLastItemId = state.timelineItems.last.when(
          alert: (id, timestamp, severity, title, message) => id,
          suggestion: (id, suggestionType, timestamp, content, actionData, actionQuery, actionDisplayText) => id,
          chat: (id, timestamp, messageText, senderNickname, isOwnMessage) => id,
          chatWithAction: (id, timestamp, messageText, senderNickname, isOwnMessage, requiresAction, actionData) => id,
        );
      }

      if (actualLastItemId == null && state.timelineItems.isNotEmpty) {
        state = state.copyWith(isLoading: false, hasMoreItems: false);
        return;
      }
      final newItems = await _apiService.getMoreTimelineItems(
        actualLastItemId!,
      );
      state = state.copyWith(
        timelineItems: [...state.timelineItems, ...newItems],
        isLoading: false,
        hasMoreItems: newItems.isNotEmpty,
      );
    } catch (e) {
      state = state.copyWith(isLoading: false, errorMessage: e.toString());
    }
  }

  void updateChatInput(String input) {
    state = state.copyWith(currentChatInput: input);
  }

  void cancelChatMessage() {
    final cancelToken = state.chatCancelToken;
    if (cancelToken != null && !cancelToken.isCancelled) {
      cancelToken.cancel('User cancelled chat message');
    }
    
    state = state.copyWith(
      isChatLoading: false,
      chatLoadingStatus: '',
      chatCancelToken: null,
    );
  }

  Future<void> sendChatMessage(String messageText) async {
    if (messageText.isEmpty) return;

    // Create cancel token for this chat request
    final cancelToken = CancelToken();

    // Set chat loading state with detailed status (scrollBehaviorは後で設定)
    state = state.copyWith(
      isChatLoading: true,
      chatLoadingStatus: 'メッセージを準備中...',
      chatCancelToken: cancelToken,
    );

    final tempId = DateTime.now().millisecondsSinceEpoch.toString();
    // Directly create TimelineItemModel without intermediate ChatMessageModel
    final tempTimelineItem = TimelineItemModel.chat(
      id: tempId,
      timestamp: DateTime.now(),
      messageText: messageText,
      senderNickname: 'You',
      isOwnMessage: true,
    );

    try {
      // Update status
      state = state.copyWith(chatLoadingStatus: 'デバイス情報を取得中...');
      
      final deviceId = await ref
          .read(deviceStatusProvider.notifier)
          .getDeviceId();

      // 言語コードを取得（LocalStorageから直接読み込み）
      String language = 'ja'; // デフォルト
      try {
        final localStorage = ref.read(localStorageServiceProvider);
        final directSettings = await localStorage.loadUserSettings();
        if (directSettings != null && directSettings.languageCode.isNotEmpty) {
          language = directSettings.languageCode;
        } else {
          // フォールバック：SettingsProviderを確認
          final settingsState = ref.read(settingsProvider);
          if (!settingsState.isLoading && settingsState.currentUserSettings != null) {
            language = settingsState.currentUserSettings!.languageCode;
          }
        }
      } catch (e) {
      // debugPrint('[TimelineProvider] Failed to load language settings: $e');
      }
      
      // debugPrint('[TimelineProvider] Using language for chat: $language');

      // Update status
      state = state.copyWith(chatLoadingStatus: 'コンテキストを取得中...');

      // 並列処理で必要なデータを取得
      final results = await Future.wait([
        // チャット履歴の構築
        Future(() {
          return state.timelineItems
              .where((item) => item.type == TimelineItemType.chat)
              .take(10)
              .map(
                (item) => item.when(
                  alert: (_, __, ___, ____, _____) => null,
                  suggestion:
                      (
                        _,
                        __,
                        ___,
                        ____,
                        _____,
                        ______,
                        _______,
                      ) => null,
                  chat: (_, __, messageText, senderNickname, isOwnMessage) =>
                      Tuple2(isOwnMessage ? 'human' : 'assistant', messageText),
                  chatWithAction: (_, __, messageText, senderNickname, isOwnMessage, requiresAction, actionData) =>
                      Tuple2(isOwnMessage ? 'human' : 'assistant', messageText),
                ),
              )
              .where((tuple) => tuple != null)
              .cast<Tuple2<String, String>>()
              .toList()
              .reversed
              .toList();
        }),
        
        // Location removed - using cached location from device status
        Future.value(ref.read(deviceStatusProvider).currentLocation),
        
        // デバイスステータスの取得
        Future(() => ref.read(deviceStatusProvider)),
      ]);

      final chatHistory = results[0] as List<Tuple2<String, String>>;
      final currentLocation = results[1] as LocationModel?;
      final deviceStatusState = results[2] as DeviceStatusState;
      final isEmergencyMode = deviceStatusState.currentMode == 'emergency';
      
      // デバッグ：提案カードからの位置情報送信状態をログ出力
      if (kDebugMode) {
        print('[TimelineProvider] 📍 === LOCATION DEBUG START ===');
        print('[TimelineProvider] 📍 Message type: TIMELINE ACTION QUERY');
        print('[TimelineProvider] 📍 Message: ${messageText.substring(0, messageText.length > 50 ? 50 : messageText.length)}...');
        if (currentLocation != null) {
          print('[TimelineProvider] ✅ Location available:');
          print('[TimelineProvider]   - Latitude: ${currentLocation.latitude}');
          print('[TimelineProvider]   - Longitude: ${currentLocation.longitude}');
          print('[TimelineProvider]   - Accuracy: ${currentLocation.accuracy}m');
        } else {
          print('[TimelineProvider] ❌ Location NOT available (timeout or error)');
        }
        print('[TimelineProvider] 📍 === LOCATION DEBUG END ===');
      }

      // Add user message to timeline after building chat history
      state = state.copyWith(
        timelineItems: [...state.timelineItems, tempTimelineItem],
        currentChatInput: '',
        scrollBehavior: TimelineScrollBehavior.toBottom, // ユーザーメッセージ追加後にスクロール
      );
      
      // debugPrint('[TimelineProvider] === SENDING CHAT MESSAGE ===');
      // debugPrint('[TimelineProvider] Current mode: ${deviceStatusState.currentMode}');
      // debugPrint('[TimelineProvider] Is emergency mode: $isEmergencyMode');
      // debugPrint('[TimelineProvider] Message: $messageText');

      // Update status
      state = state.copyWith(chatLoadingStatus: 'メッセージを送信中...');

      // Get emergency contacts count
      final emergencyContactsCount = await _getEmergencyContactsCount();
      
      final apiResponse = await _apiService.sendChatMessage(
        message: messageText,
        deviceId: deviceId,
        sessionId: DateTime.now().millisecondsSinceEpoch.toString(),
        language: language,
        chatHistory: chatHistory,
        currentLocation: currentLocation,
        isDisasterMode: isEmergencyMode,
        emergencyContactsCount: emergencyContactsCount,
        cancelToken: cancelToken,
      );

      // Update status
      state = state.copyWith(chatLoadingStatus: 'AIが回答を生成中...');

      // 型安全なAPIレスポンスからエージェントの回答を取得
      final responseText = apiResponse.responseText;
      final generatedCards = apiResponse.generatedCardsForFrontend;
      final requiresAction = apiResponse.requiresAction;
      final actionData = apiResponse.actionData;
      
      // 🔍 SMS フォーム関連のデバッグログ
      debugPrint('[TimelineProvider] requiresAction: $requiresAction');
      debugPrint('[TimelineProvider] actionData: ${actionData != null ? 'Present' : 'null'}');
      if (requiresAction != null) {
        debugPrint('[TimelineProvider] Action required: $requiresAction');
      }

      if (responseText != null && responseText.isNotEmpty) {
        // スクロール動作がtoBottomの場合は新規ID、それ以外はtargetResponseIdを使用
        final agentMessageId = (state.scrollBehavior == TimelineScrollBehavior.toBottom) 
            ? DateTime.now().millisecondsSinceEpoch.toString()
            : (state.targetResponseId ?? DateTime.now().millisecondsSinceEpoch.toString());
        
        // アクションが必要な場合は特別なチャットアイテムを作成
        if (requiresAction != null && actionData != null) {
          // ChatWithActionItemを作成してアクションを処理
          final agentMessage = TimelineItemModel.chatWithAction(
            id: agentMessageId,
            timestamp: DateTime.now(),
            messageText: responseText,
            senderNickname: 'SafetyBee',
            isOwnMessage: false,
            requiresAction: requiresAction,
            actionData: actionData,
          );
          
          state = state.copyWith(
            timelineItems: [...state.timelineItems, agentMessage],
            isChatLoading: false,
            chatLoadingStatus: '',
          );
          
          // チャット完了をDeviceStatusProviderに通知
          ref.read(deviceStatusProvider.notifier).endChatSession();
          
          // 永続化
          _saveTimeline();
          
          return; // アクション付きチャットの場合はここで処理終了
        }
        
        // 通常のチャットメッセージ
        final agentMessage = TimelineItemModel.chat(
          id: agentMessageId,
          timestamp: DateTime.now(),
          messageText: responseText,
          senderNickname: 'SafetyBee',
          isOwnMessage: false,
        );


        // まず現在のタイムラインアイテムをコピー
        List<TimelineItemModel> newTimelineItems = [...state.timelineItems];

        // カードデータがある場合は、カードタイプ別に処理
        if (generatedCards != null && generatedCards.isNotEmpty) {
      // debugPrint('[TimelineProvider] 🗺️ Processing generated cards...');
          for (final card in generatedCards) {
      // debugPrint('[TimelineProvider] Card: type=${card['type']}, card_type=${card['card_type']}, title=${card['title']}');
            // Debug location data
            final location = card['location'] as Map<String, dynamic>?;
            if (location != null) {
      // debugPrint('[TimelineProvider] 🗺️ Card location: lat=${location['latitude']}, lng=${location['longitude']}');
            } else {
      // debugPrint('[TimelineProvider] 🗺️ Card has no location data');
            }
          }
          
          // 避難所関連タイプをフィルタリング（位置情報があるもののみ）
          final shelterCards = generatedCards
              .where((card) {
                // 避難所関連のタイプをチェック
                final isEvacuationType = 
                  card['type'] == 'shelter_status_update' ||
                  card['card_type'] == 'evacuation_info' ||
                  card['type'] == 'shelter_location' ||
                  card['type'] == 'shelter_info' ||
                  card['card_type'] == 'evacuation_shelter' ||
                  card['card_type'] == 'shelter' ||
                  card['type'] == 'evacuation_shelter' ||
                  card['type'] == 'shelter';
                
                if (!isEvacuationType) return false;
                
                // 位置情報（緯度経度）があるかチェック
                final location = card['location'] as Map<String, dynamic>?;
                final data = card['data'] as Map<String, dynamic>?;
                
                final hasLatitude = location?['latitude'] != null || 
                                   data?['latitude'] != null ||
                                   card['shelter_latitude'] != null;
                final hasLongitude = location?['longitude'] != null || 
                                     data?['longitude'] != null ||
                                     card['shelter_longitude'] != null;
                
                return hasLatitude && hasLongitude;
              })
              .toList();
              
          // 一般的なアクションカードをフィルタリング（避難所関連以外）
          final actionCards = generatedCards
              .where((card) {
                final cardType = card['type'] as String?;
                final cardCardType = card['card_type'] as String?;
                
                // 避難所関連は除外（上で別処理）
                final isEvacuationType = 
                  cardType == 'shelter_status_update' ||
                  cardCardType == 'evacuation_info' ||
                  cardType == 'shelter_location' ||
                  cardType == 'shelter_info' ||
                  cardCardType == 'evacuation_shelter' ||
                  cardCardType == 'shelter' ||
                  cardType == 'evacuation_shelter' ||
                  cardType == 'shelter';
                  
                if (isEvacuationType) return false;
                
                // 一般的なカードタイプを含める
                return cardType == 'action' ||
                       cardType == 'preparedness_tip' ||
                       cardType == 'guide_info' ||  // ガイド情報カードを追加
                       cardType == 'disaster_info' ||  // 災害情報カードを追加
                       cardCardType == 'hazard_map_info' ||
                       cardCardType == 'hazard_map_viewer' ||
                       cardCardType == 'guide_info' ||  // card_typeとしてのguide_infoも追加
                       card.containsKey('action_query'); // action_queryがあるものは全て含める
              })
              .toList();

          if (shelterCards.isNotEmpty) {

            // 現在の位置情報を取得（キャッシュを使用）
            final currentLocation = ref.read(deviceStatusProvider).currentLocation;
            LatLng? userLocation;
            if (currentLocation != null) {
              userLocation = LatLng(
                currentLocation.latitude,
                currentLocation.longitude,
              );
            }

            // 避難所データを事前処理してキャッシュに保存
            final processedShelters = _preprocessShelterData(shelterCards);
            final shelterData = {
              'shelters': shelterCards,
              'processedShelters': processedShelters, // 事前処理済みデータを追加
              'userLocation': userLocation != null
                  ? {
                      'latitude': userLocation.latitude,
                      'longitude': userLocation.longitude,
                    }
                  : null,
            };
            
            // データのハッシュベースでユニークなIDを生成
            final shelterDataHash = _generateShelterDataHash(shelterData);
            final shelterMapId = 'shelter_map_$shelterDataHash';
            
            // 既存のキャッシュをチェック
            final updatedCache = {...state.shelterDataCache};
            if (!updatedCache.containsKey(shelterMapId)) {
              // 新しいデータのみキャッシュに追加
              updatedCache[shelterMapId] = shelterData;
            }
            
            // 状態を更新してキャッシュを保存
            state = state.copyWith(shelterDataCache: updatedCache);
            
            // チャットメッセージIDと避難所データIDのマッピングを保存
            final updatedMapping = {...state.chatIdToShelterDataId};
            updatedMapping[agentMessageId] = shelterMapId;
            state = state.copyWith(chatIdToShelterDataId: updatedMapping);
            
            // 避難所データを永続化
            _saveTimeline();
          }

          // 一般的なアクションカードの処理
          if (actionCards.isNotEmpty) {
            for (final actionCard in actionCards) {
              final cardType = actionCard['type'] as String? ?? actionCard['card_type'] as String? ?? 'unknown';
              final cardId = actionCard['card_id'] as String? ?? 'action_${DateTime.now().millisecondsSinceEpoch}';
              
              // アクションカードタイプ別の処理
              if (cardType == 'action') {
                // clarification_handlerからのアクションカード
                final suggestionCard = TimelineItemModel.suggestion(
                  id: cardId,
                  suggestionType: 'action_selection',
                  content: actionCard['text'] as String? ?? 'アクションを選択',
                  actionData: {
                    'action_type': actionCard['action'],
                    'original_card_data': actionCard,
                  },
                  actionQuery: _generateActionQuery(actionCard['action'] as String?),
                  actionDisplayText: actionCard['text'] as String? ?? '選択',
                  timestamp: DateTime.now(),
                );
                newTimelineItems.add(suggestionCard);
                
              } else if (cardType == 'preparedness_tip') {
                // 準備・チェックリストカード
                final suggestionCard = TimelineItemModel.suggestion(
                  id: cardId,
                  suggestionType: 'preparedness_tip',
                  content: actionCard['title'] as String? ?? actionCard['content'] as String? ?? '準備チェックリスト',
                  actionData: {
                    'tip_data': actionCard,
                    'checklist_items': actionCard['checklist_items'],
                  },
                  actionQuery: actionCard['action_query'] as String?,
                  actionDisplayText: actionCard['action_display_text'] as String? ?? 'チェック',
                  timestamp: DateTime.now(),
                );
                newTimelineItems.add(suggestionCard);
                
              } else if (actionCard['card_type'] == 'hazard_map_info' || actionCard['card_type'] == 'hazard_map_viewer') {
                // ハザードマップカード
                final actionButtons = actionCard['action_buttons'] as List<dynamic>?;
                
                if (actionButtons != null && actionButtons.isNotEmpty) {
                  // 新しい形式: action_buttons配列から複数のボタンを生成
                  for (int i = 0; i < actionButtons.length; i++) {
                    final button = actionButtons[i] as Map<String, dynamic>;
                    final hazardMapId = '${cardId}_button_$i';
                    
                    final hazardMapCard = TimelineItemModel.suggestion(
                      id: hazardMapId,
                      suggestionType: 'hazard_map_url',
                      content: actionCard['title'] ?? 'ハザードマップ',
                      actionData: {
                        'action': 'open_hazard_map',
                        'url': button['url'],
                        'title': button['label'] ?? actionCard['title'],
                        'description': actionCard['description'],
                      },
                      actionQuery: null,
                      actionDisplayText: button['label'] ?? 'ハザードマップを開く',
                      timestamp: DateTime.now(),
                    );
                    newTimelineItems.add(hazardMapCard);
                  }
                } else {
                  // 旧形式: 単一のaction_url
                  final hazardMapCard = TimelineItemModel.suggestion(
                    id: cardId,
                    suggestionType: 'hazard_map_url',
                    content: actionCard['title'] ?? 'ハザードマップ',
                    actionData: {
                      'action': 'open_hazard_map',
                      'url': actionCard['action_url'],
                      'title': actionCard['title'],
                      'description': actionCard['description'],
                    },
                    actionQuery: null,
                    actionDisplayText: 'ハザードマップを開く',
                    timestamp: DateTime.now(),
                  );
                  newTimelineItems.add(hazardMapCard);
                }
              } else {
                // その他の一般的なカード（action_queryがあるもの）
                final suggestionCard = TimelineItemModel.suggestion(
                  id: cardId,
                  suggestionType: cardType,
                  content: actionCard['title'] as String? ?? actionCard['content'] as String? ?? 'カード',
                  actionData: {
                    'card_data': actionCard,
                  },
                  actionQuery: actionCard['action_query'] as String?,
                  actionDisplayText: actionCard['action_display_text'] as String? ?? 'アクション',
                  timestamp: DateTime.now(),
                );
                newTimelineItems.add(suggestionCard);
              }
            }
          }
        }

        // 最後にエージェントメッセージを追加
        newTimelineItems.add(agentMessage);

        state = state.copyWith(
          timelineItems: newTimelineItems,
          isChatLoading: false,
          chatLoadingStatus: '',
          scrollBehavior: TimelineScrollBehavior.toBottom, // AI返答後も最下部へスクロール
        );

        // チャット完了をDeviceStatusProviderに通知
        if (!_isDisposed) {
          ref.read(deviceStatusProvider.notifier).endChatSession();
        }

      } else {
        if (!_isDisposed) {
          state = state.copyWith(
            isChatLoading: false,
            chatLoadingStatus: '',
          );
        }
        
        // チャット完了をDeviceStatusProviderに通知（レスポンスなし時）
        if (!_isDisposed) {
          ref.read(deviceStatusProvider.notifier).endChatSession();
        }
      }
    } catch (e, stackTrace) {
      // debugPrint('[TimelineProvider] Failed to send chat message: $e');
      // debugPrint('[TimelineProvider] Stack trace: $stackTrace');
      
      if (_isDisposed) {
      // debugPrint('Provider disposed during chat message, skipping state update');
        return;
      }
      
      // Check if error is due to cancellation
      String errorMessage;
      if (e is DioException && e.type == DioExceptionType.cancel) {
        errorMessage = "メッセージ送信がキャンセルされました";
      } else {
        errorMessage = "Failed to send message: ${e.toString()}";
      }
      
      state = state.copyWith(
        errorMessage: errorMessage,
        timelineItems: state.timelineItems
            .where((item) => item != tempTimelineItem)
            .toList(),
        isChatLoading: false,
        chatLoadingStatus: '',
        chatCancelToken: null,
      );
      
      // チャット完了をDeviceStatusProviderに通知（エラー時）
      if (!_isDisposed) {
        ref.read(deviceStatusProvider.notifier).endChatSession();
      }
    }
  }

  void setImportantAlert(AlertModel? alert) {
    state = state.copyWith(importantAlert: alert);
  }

  /// FCMから受信した災害アラートを処理
  /// 統一されたアラート処理メソッド（FCMからのみ呼び出される）
  void processEmergencyAlert(Map<String, dynamic> alertData) {
      // debugPrint('[TimelineProvider] Processing FCM emergency alert');

    // 1. アラートID生成（重複防止のため）
    final alertId = alertData['alert_id'] ?? alertData['id'] ?? '';
    final alertTimestamp = DateTime.tryParse(alertData['timestamp'] ?? '') ?? DateTime.now();
    final uniqueAlertId = alertId.isNotEmpty 
        ? alertId 
        : 'alert_${alertTimestamp.millisecondsSinceEpoch}';

    // 2. 包括的重複チェック（ID + タイプ + 24時間以内）
    final isDuplicate = _isAlertDuplicate(uniqueAlertId, alertTimestamp);
    if (isDuplicate) {
      // debugPrint('[TimelineProvider] Duplicate alert detected, skipping');
      return;
    }

    // 3. アラートデータ抽出とローカライズ
    final alertType = alertData['alert_type'] ?? alertData['disaster_type'] ?? 'emergency';
    final userLanguage = ref.read(settingsProvider).currentUserSettings?.languageCode ?? 'ja';
    
    // タイトルとメッセージをローカライズ
    final localizedData = _getLocalizedAlertContent(alertType, userLanguage);
    final title = localizedData['title'] ?? alertData['title'] ?? '緊急アラート';
    final message = localizedData['message'] ?? alertData['body'] ?? alertData['description'] ?? '';
    
    final severity = _parseAlertSeverity(
      alertData['disaster_level'] ?? alertData['severity'] ?? 'emergency',
    );

    // 4. AlertModel作成
    final alert = AlertModel(
      id: uniqueAlertId,
      title: title,
      message: message,
      severity: severity,
      timestamp: alertTimestamp,
      source: alertData['disaster_type'] ?? alertData['alert_type'] ?? 'emergency',
      area: alertData['area'] ?? '対象地域',
    );

    // 5. ImportantAlertBanner設定（最新アラートのみ）
    setImportantAlert(alert);

    // 6. TimelineItem追加
    final alertItem = TimelineItemModel.alert(
      id: 'timeline_$uniqueAlertId',
      timestamp: alert.timestamp,
      severity: alert.severity.name,
      title: alert.title,
      message: alert.message,
    );

    state = state.copyWith(
      timelineItems: [...state.timelineItems, alertItem],
      scrollBehavior: TimelineScrollBehavior.toAlert,
      targetAlertId: alertItem.id,
    );
    
    // 7. タイムライン永続化（緊急アラートは即座に保存）
    _saveTimelineImmediate();

    // 8. 緊急モード提案の取得と自動緊急モード切り替え
    if (severity == AlertSeverity.emergency || severity == AlertSeverity.critical) {
      // 緊急アラート受信時に自動的に緊急モードに切り替え
      if (ref.exists(deviceStatusProvider)) {
        ref.read(deviceStatusProvider.notifier).setEmergencyMode(true);
        // debugPrint('[TimelineProvider] Emergency alert received - switching to emergency mode');
      }
      
      // 緊急モード提案はDeviceStatusProviderのハートビートで自動的に取得される
      // debugPrint('[TimelineProvider] Emergency alert processed - suggestions will be fetched via heartbeat');
    }
  }

  /// 重複アラートチェック（24時間以内の同一アラート）
  bool _isAlertDuplicate(String alertId, DateTime timestamp) {
    const duplicateWindow = Duration(hours: 24);
    final cutoffTime = timestamp.subtract(duplicateWindow);
    
    return state.timelineItems.any((item) =>
        item.when(
          alert: (id, itemTimestamp, __, ___, ____) {
            // IDが同じ、または24時間以内の同一タイムスタンプ
            return (id.contains(alertId) && alertId.isNotEmpty) ||
                   (itemTimestamp.isAfter(cutoffTime) && 
                    itemTimestamp.difference(timestamp).abs() < const Duration(seconds: 1));
          },
          suggestion: (_, __, ___, ____, _____, ______, _______) => false,
          chat: (_, __, ___, ____, _____) => false,
          chatWithAction: (_, __, ___, ____, _____, ______, _______) => false,
        ));
  }

  /// 後方互換性のため旧メソッドを新メソッドに転送
  void handleDisasterAlert(Map<String, dynamic> alertData) {
      // debugPrint('[TimelineProvider] ⚠️ Legacy handleDisasterAlert called, forwarding to processEmergencyAlert');
    processEmergencyAlert(alertData);
  }

  /// 文字列をAlertSeverityに変換
  AlertSeverity _parseAlertSeverity(String severityStr) {
    switch (severityStr.toLowerCase()) {
      case 'info':
        return AlertSeverity.info;
      case 'warning':
        return AlertSeverity.warning;
      case 'danger':
        return AlertSeverity.danger;
      case 'emergency':
        return AlertSeverity.emergency;
      case 'critical':
        return AlertSeverity.critical;
      default:
        return AlertSeverity.emergency;
    }
  }

  void clearErrorMessage() {
    state = state.copyWith(errorMessage: null);
  }

  void dismissImportantAlert() {
    state = state.copyWith(importantAlert: null);
  }

  /// Clear normal mode suggestions when switching to emergency mode
  void clearNormalModeSuggestions() {
    
    // Define emergency suggestion types that should be kept
    const emergencySuggestionTypes = {
      'immediate_safety_action',
      'evacuation_prompt',
      'emergency_guidance',
      'disaster_info',
      'evacuation_instruction',
      'publicSafetyInfoForCurrentLocation',
      'safety_confirmation_sms_proposal',
      'hazard_map_url',
      'shelter_info',
      'shelter_status_update',
    };
    
    // Filter out normal mode suggestions
    final filteredItems = state.timelineItems.where((item) {
      return item.when(
        alert: (_, __, ___, ____, _____) => true, // Keep all alerts
        chat: (_, __, ___, ____, _____) => true, // Keep all chats
        chatWithAction: (_, __, ___, ____, _____, ______, _______) => true, // Keep all chat with actions
        suggestion: (_, __, suggestionType, ____, actionData, _____, ______) {
          // Keep only emergency-related suggestions
          return emergencySuggestionTypes.contains(suggestionType);
        },
      );
    }).toList();
    
    
    state = state.copyWith(timelineItems: filteredItems);
    _saveTimelineImmediate();
  }

  /// Clear emergency mode suggestions when switching back to normal mode
  void clearEmergencyModeSuggestions() {
    
    // Define emergency suggestion types that should be removed
    const emergencySuggestionTypes = {
      'immediate_safety_action',
      'evacuation_prompt',
      'emergency_guidance',
      'disaster_info',
      'evacuation_instruction',
      'publicSafetyInfoForCurrentLocation',
      'safety_confirmation_sms_proposal',
      'hazard_map_url',
      'shelter_info',
      'shelter_status_update',
    };
    
    // Filter out emergency mode suggestions
    final filteredItems = state.timelineItems.where((item) {
      return item.when(
        alert: (_, __, severity, ____, _____) {
          // Remove emergency alerts
          return severity != 'critical' && severity != 'warning';
        },
        chat: (_, __, ___, ____, _____) => true, // Keep all chats
        chatWithAction: (_, __, ___, ____, _____, ______, _______) => true, // Keep all chat with actions
        suggestion: (_, __, suggestionType, ____, actionData, _____, ______) {
          // Remove emergency-related suggestions
          return !emergencySuggestionTypes.contains(suggestionType);
        },
      );
    }).toList();
    
    
    state = state.copyWith(timelineItems: filteredItems);
    _saveTimelineImmediate();
  }


  /// 緊急モード検出時のSSE自動開始（無効化済み）
  void _checkEmergencyModeForSSE() {
    // ハートビート統合により無効化
  }

  /// ハートビートAPIから受信したプロアクティブ提案の処理
  void addProactiveSuggestions(List<TimelineItemModel> suggestions) async {
    // Turn off loading state after receiving first response
    if (state.isLoading) {
      state = state.copyWith(isLoading: false);
    }
    
    if (suggestions.isEmpty) {
      // debugPrint('[TimelineProvider] ⚠️ No suggestions to add - returning early');
      return;
    }
    
      // debugPrint('[TimelineProvider] 📥 Received ${suggestions.length} suggestions - processing for duplicates');
    
    // 受信した提案を参考情報としてログ出力
    for (int i = 0; i < suggestions.length; i++) {
      final suggestion = suggestions[i];
      suggestion.when(
        alert: (id, timestamp, severity, title, message) {
      // debugPrint('[TimelineProvider]   [$i] ALERT: $id - $title');
        },
        suggestion: (id, suggestionType, timestamp, content, actionData, actionQuery, actionDisplayText) {
      // debugPrint('[TimelineProvider]   [$i] SUGGESTION: $id ($suggestionType) - ${content.substring(0, content.length.clamp(0, 50))}...');
        },
        chat: (id, timestamp, messageText, senderNickname, isOwnMessage) {
      // debugPrint('[TimelineProvider]   [$i] CHAT: $id - ${messageText.substring(0, messageText.length.clamp(0, 50))}...');
        },
        chatWithAction: (id, timestamp, messageText, senderNickname, isOwnMessage, requiresAction, actionData) {
      // debugPrint('[TimelineProvider]   [$i] CHAT WITH ACTION: $id - ${messageText.substring(0, messageText.length.clamp(0, 50))}...');
        },
      );
    }
    
    // 既存のタイムラインから重複する提案を除外（タイプと内容で判定）
    final existingSuggestions = state.timelineItems
        .where((item) => item.type == TimelineItemType.suggestion)
        .map((item) => item.when(
              alert: (_, __, ___, ____, _____) => null,
              chat: (_, __, ___, ____, _____) => null,
              chatWithAction: (_, __, ___, ____, _____, ______, _______) => null,
              suggestion: (id, suggestionType, timestamp, content, _____, ______, _______) => {
                'id': id,
                'type': suggestionType,
                'content': content,
                'timestamp': timestamp.toIso8601String(),
              },
            ))
        .where((item) => item != null)
        .cast<Map<String, String>>()
        .toList();

    // 既存のアラートIDを取得（災害情報の重複チェック用）
    final existingAlertIds = state.timelineItems
        .where((item) => item.type == TimelineItemType.alert)
        .map((item) => item.when(
              alert: (id, __, ___, ____, _____) => id,
              chat: (_, __, ___, ____, _____) => '',
              chatWithAction: (_, __, ___, ____, _____, ______, _______) => '',
              suggestion: (_, __, ___, ____, _____, ______, _______) => '',
            ))
        .where((id) => id.isNotEmpty)
        .toSet();

      // debugPrint('[TimelineProvider] 🔍 Existing content check:');
      // debugPrint('[TimelineProvider]   - Existing alert IDs: $existingAlertIds');

    
    // デバイス状態を取得（緊急モード判定用）
    final deviceStatus = ref.read(deviceStatusProvider);
    final isCurrentlyEmergencyMode = deviceStatus.currentMode == 'emergency';
    
    // 重複していない提案のみフィルタリング（提案タイプと災害情報重複で判定）
    final newSuggestions = suggestions.where((suggestion) {
      return suggestion.when(
        alert: (_, __, ___, ____, _____) => true,
        chat: (_, __, ___, ____, _____) => true,
        chatWithAction: (_, __, ___, ____, _____, ______, _______) => true,
        suggestion: (_, suggestionType, __, content, actionData, _____, ______) {
          // 内容ベースの重複チェック
          final isDuplicate = _isDuplicateSuggestion(suggestionType, content, existingSuggestions);
          if (isDuplicate) {
      // debugPrint('[TimelineProvider] 🚫 Duplicate suggestion filtered: $suggestionType');
          } else {
      // debugPrint('[TimelineProvider] ✅ New suggestion accepted: $suggestionType');
          }
          return !isDuplicate;
        },
      );
    }).toList();

      // debugPrint('[TimelineProvider] 🔍 Duplicate check results:');
      // debugPrint('[TimelineProvider]   - Existing suggestions in timeline: ${existingSuggestions.length}');
    final existingTypes = existingSuggestions.map((s) => s['type']).toSet();
      // debugPrint('[TimelineProvider]   - Existing suggestion types: $existingTypes');
      // debugPrint('[TimelineProvider]   - New suggestions received: ${suggestions.length}');
      // debugPrint('[TimelineProvider]   - After duplicate filtering: ${newSuggestions.length}');
      // debugPrint('[TimelineProvider]   - Emergency mode: $isCurrentlyEmergencyMode');
    
    if (newSuggestions.isNotEmpty) {
      // debugPrint('[TimelineProvider] 🔄 Filtered out ${suggestions.length - newSuggestions.length} duplicate suggestions');
      
      // タイムラインに新しい提案を追加（下に追加：上が古い、下が新しい）
      state = state.copyWith(
        timelineItems: [...state.timelineItems, ...newSuggestions],
      );
      
      // タイムラインを保存
      _saveTimeline();
      
      // 緊急モード時のSSEチェック
      _checkEmergencyModeForSSE();
      
      // debugPrint('[TimelineProvider] ✅ Added ${newSuggestions.length} new suggestions to timeline');
    } else {
      // debugPrint('[TimelineProvider] ⚠️ All suggestions were duplicates - not adding any');
    }
  }

  /// SSEストリーミングから受信した提案をタイムラインに追加
  void addStreamingSuggestion(TimelineItemModel suggestion) {
    // 単一の提案をリストとして処理
    addProactiveSuggestions([suggestion]);
  }

  /// プロアクティブ提案をタップした際に、actionQueryを送信してエージェントの回答を取得
  Future<void> sendSuggestionQuery(TimelineItemModel suggestion) async {
    await suggestion.when(
      alert: (_, __, ___, ____, _____) async {
        // アラートの場合は何もしない
      },
      suggestion:
          (
            _,
            __,
            ___,
            content,
            actionData,
            actionQuery,
            actionDisplayText,
          ) async {
            final query = actionQuery ?? "この提案について教えてください";
            final displayText = actionDisplayText ?? content;
            await sendActionQuery(
              query,
              displayText,
            );
          },
      chat: (_, __, ___, ____, _____) async {
        // チャットの場合は何もしない
      },
      chatWithAction: (_, __, ___, ____, _____, ______, _______) async {
        // チャットアクションの場合は何もしない
      },
    );
  }

  /// プロアクティブ提案をタップした際に、actionQueryを送信してエージェントの回答を取得
  Future<void> sendActionQuery(
    String actionQuery,
    String displayText,
  ) async {
    if (actionQuery.isEmpty) return;

    // チャット開始をDeviceStatusProviderに通知
    ref.read(deviceStatusProvider.notifier).startChatSession();

    // ユーザーのクエリをタイムラインに追加（actionQueryではなくdisplayTextを表示）
    final userMessageId = DateTime.now().millisecondsSinceEpoch.toString();
    final userMessage = TimelineItemModel.chat(
      id: userMessageId,
      timestamp: DateTime.now(),
      messageText: displayText,
      senderNickname: 'You',
      isOwnMessage: true,
    );

    // Response IDを生成（この後追加される回答のID）
    final responseId = 'response_${DateTime.now().millisecondsSinceEpoch}';
    
    state = state.copyWith(
      timelineItems: [...state.timelineItems, userMessage],
      isChatLoading: true,
      scrollBehavior: TimelineScrollBehavior.toResponse,
      targetResponseId: responseId,
    );

    try {
      // 並列処理で必要なデータを取得
      final results = await Future.wait([
        // デバイスID取得
        ref.read(deviceStatusProvider.notifier).getDeviceId(),
        
        // Location removed - using cached location from device status
        Future.value(ref.read(deviceStatusProvider).currentLocation),
        
        // チャット履歴構築（同期処理なのでFuture.valueでラップ）
        Future.value(state.timelineItems
            .where((item) => item.type == TimelineItemType.chat)
            .take(10)
            .map((item) => item.when(
                  alert: (_, __, ___, ____, _____) => null,
                  suggestion: (_, __, ___, ____, _____, ______, _______) => null,
                  chat: (_, __, messageText, senderNickname, isOwnMessage) =>
                      Tuple2(isOwnMessage ? 'human' : 'assistant', messageText),
                  chatWithAction: (_, __, messageText, senderNickname, isOwnMessage, requiresAction, actionData) =>
                      Tuple2(isOwnMessage ? 'human' : 'assistant', messageText),
                ))
            .where((tuple) => tuple != null)
            .cast<Tuple2<String, String>>()
            .toList()
            .reversed
            .toList()),
      ]);

      final deviceId = results[0] as String;
      final currentLocation = results[1] as LocationModel?;
      final chatHistory = results[2] as List<Tuple2<String, String>>;

      // 言語コードを取得（LocalStorageから直接読み込み - sendChatMessageと同じロジック）
      String language = 'ja'; // デフォルト
      try {
        final localStorage = ref.read(localStorageServiceProvider);
        final directSettings = await localStorage.loadUserSettings();
        if (directSettings != null && directSettings.languageCode.isNotEmpty) {
          language = directSettings.languageCode;
        } else {
          // フォールバック：SettingsProviderを確認
          final settingsState = ref.read(settingsProvider);
          if (!settingsState.isLoading && settingsState.currentUserSettings != null) {
            language = settingsState.currentUserSettings!.languageCode;
          }
        }
      } catch (e) {
      // debugPrint('[TimelineProvider] Language retrieval failed: $e');
      }
      
      // debugPrint('[TimelineProvider] Using language: $language');
      
      // デバイスステータス確認
      final deviceStatusState = ref.read(deviceStatusProvider);
      final isEmergencyMode = deviceStatusState.currentMode == 'emergency';
      
      // debugPrint('[TimelineProvider] === SENDING ACTION QUERY ===');
      // debugPrint('[TimelineProvider] Current mode: ${deviceStatusState.currentMode}');
      // debugPrint('[TimelineProvider] Is emergency mode: $isEmergencyMode');
      // debugPrint('[TimelineProvider] Action query: $actionQuery');

      final apiResponse = await _apiService.sendChatMessage(
        message: actionQuery,
        deviceId: deviceId,
        sessionId: DateTime.now().millisecondsSinceEpoch.toString(),
        language: language,
        chatHistory: chatHistory,
        currentLocation: currentLocation,
        isDisasterMode: isEmergencyMode,
      );

      // debugPrint('Action query sent: $actionQuery');
      // debugPrint('Display text: $displayText');
      // debugPrint('API response: $apiResponse');

      // 型安全なAPIレスポンスからエージェントの回答を取得
      final responseText = apiResponse.responseText;
      final generatedCards = apiResponse.generatedCardsForFrontend;

      // debugPrint('[TimelineProvider] Processing action query API response...');
      // debugPrint('[TimelineProvider] Response text: $responseText');
      // debugPrint('[TimelineProvider] Generated cards: $generatedCards');

      if (responseText != null && responseText.isNotEmpty) {
        // responseIdを直接使用（sendActionQuery開始時に生成したID）
        final agentMessageId = responseId;
      // debugPrint('[TimelineProvider] Creating agent message with ID: $agentMessageId');
      // debugPrint('[TimelineProvider] Using responseId from start of sendActionQuery: $responseId');
      // debugPrint('[TimelineProvider] Current targetResponseId in state: ${state.targetResponseId}');
      // debugPrint('[TimelineProvider] Current scrollBehavior: ${state.scrollBehavior}');
        
        // メッセージはそのまま使用
        String finalMessageText = responseText;

        // まず現在のタイムラインアイテムをコピー
        List<TimelineItemModel> updatedItems = [...state.timelineItems];

        // Generated Cards の処理
        if (generatedCards != null && generatedCards.isNotEmpty) {
          // 避難所関連タイプをフィルタリング（位置情報があるもののみ）
          final shelterCards = generatedCards
              .where((card) {
                // 避難所関連のタイプをチェック
                final isEvacuationType = 
                  card['type'] == 'shelter_status_update' ||
                  card['card_type'] == 'evacuation_info' ||
                  card['type'] == 'shelter_location' ||
                  card['type'] == 'shelter_info' ||
                  card['card_type'] == 'evacuation_shelter' ||
                  card['card_type'] == 'shelter' ||
                  card['type'] == 'evacuation_shelter' ||
                  card['type'] == 'shelter';
                
                if (!isEvacuationType) return false;
                
                // 位置情報（緯度経度）があるかチェック
                final location = card['location'] as Map<String, dynamic>?;
                final data = card['data'] as Map<String, dynamic>?;
                
                final hasLatitude = location?['latitude'] != null || 
                                   data?['latitude'] != null ||
                                   card['shelter_latitude'] != null;
                final hasLongitude = location?['longitude'] != null || 
                                     data?['longitude'] != null ||
                                     card['shelter_longitude'] != null;
                
                return hasLatitude && hasLongitude;
              })
              .toList();
          
          // 避難所データがある場合は、チャットメッセージに埋め込むための準備
          if (shelterCards.isNotEmpty) {
            // 現在の位置情報を取得（キャッシュを使用）
            final currentLocation = ref.read(deviceStatusProvider).currentLocation;
            
            // 避難所データを準備
            final shelterData = {
              'shelters': shelterCards,
              'userLocation': currentLocation != null
                  ? {
                      'latitude': currentLocation.latitude,
                      'longitude': currentLocation.longitude,
                    }
                  : null,
            };
            
            // ユニークなIDを生成してキャッシュに保存
            final shelterMapId = 'shelter_map_${agentMessageId}';
            final updatedCache = {...state.shelterDataCache};
            updatedCache[shelterMapId] = shelterData;
            
            // 状態を更新してキャッシュを保存
            state = state.copyWith(shelterDataCache: updatedCache);
            
            // チャットメッセージIDと避難所データIDのマッピングを保存
            final updatedMapping = {...state.chatIdToShelterDataId};
            updatedMapping[agentMessageId] = shelterMapId;
            state = state.copyWith(chatIdToShelterDataId: updatedMapping);
            
            // 避難所データを永続化
            _saveTimeline();
          }
          
          // ハザードマップのタイプをフィルタリング（新旧両方の形式に対応）
          final hazardMapCards = generatedCards
              .where((card) => card['card_type'] == 'hazard_map_info' || card['card_type'] == 'hazard_map_viewer')
              .toList();

          // ハザードマップカードの処理
          if (hazardMapCards.isNotEmpty) {
            for (final hazardCard in hazardMapCards) {
              
              // 新しいaction_buttons形式かチェック
              final actionButtons = hazardCard['action_buttons'] as List<dynamic>?;
              
              if (actionButtons != null && actionButtons.isNotEmpty) {
                // 新しい形式: action_buttons配列から複数のボタンを生成
                for (int i = 0; i < actionButtons.length; i++) {
                  final button = actionButtons[i] as Map<String, dynamic>;
                  final hazardMapId =
                      'hazard_map_${DateTime.now().millisecondsSinceEpoch}_${hazardCard['card_id']}_$i';
                  
                  final hazardMapCard = TimelineItemModel.suggestion(
                    id: hazardMapId,
                    suggestionType: 'hazard_map_url',
                    content: hazardCard['title'] ?? 'ハザードマップ',
                    actionData: {
                      'action': 'open_hazard_map',
                      'url': button['url'],
                      'title': button['label'] ?? hazardCard['title'],
                      'description': hazardCard['description'],
                    },
                    actionQuery: null,
                    actionDisplayText: button['label'] ?? 'ハザードマップを開く',
                    timestamp: DateTime.now(),
                  );

                  updatedItems.add(hazardMapCard);
                }
              } else {
                // 旧形式: 単一のaction_url
                final hazardMapId =
                    'hazard_map_${DateTime.now().millisecondsSinceEpoch}_${hazardCard['card_id']}';
                final hazardMapCard = TimelineItemModel.suggestion(
                  id: hazardMapId,
                  suggestionType: 'hazard_map_url',
                  content: hazardCard['title'] ?? 'ハザードマップ',
                  actionData: {
                    'action': 'open_hazard_map',
                    'url': hazardCard['action_url'],
                    'title': hazardCard['title'],
                    'description': hazardCard['description'],
                  },
                  actionQuery: null,
                  actionDisplayText: 'ハザードマップを開く',
                  timestamp: DateTime.now(),
                );

                updatedItems.add(hazardMapCard);
              }
            }
          }
          
      // debugPrint('[TimelineProvider] === END GENERATED CARDS PROCESSING (ACTION QUERY) ===');
        }

        // エージェントメッセージを作成
        final agentMessage = TimelineItemModel.chat(
          id: agentMessageId,
          timestamp: DateTime.now(),
          messageText: finalMessageText,
          senderNickname: 'SafetyBee',
          isOwnMessage: false,
        );
        
        // 最後にエージェントメッセージを追加
        updatedItems.add(agentMessage);

        // スクロール動作が既にリセットされている場合は、再設定する
        final currentScrollBehavior = state.scrollBehavior == TimelineScrollBehavior.none 
            ? TimelineScrollBehavior.toResponse 
            : state.scrollBehavior;
        
        state = state.copyWith(
          timelineItems: updatedItems,
          isChatLoading: false, // チャットローディング終了
          targetResponseId: agentMessageId, // 生成されたメッセージIDを確実に設定
          scrollBehavior: currentScrollBehavior, // スクロール動作を維持または再設定
        );
        
        // チャット完了をDeviceStatusProviderに通知
        if (!_isDisposed) {
          ref.read(deviceStatusProvider.notifier).endChatSession();
        }
      } else {
        // レスポンスがない場合もローディング終了
        if (!_isDisposed) {
          state = state.copyWith(
            isChatLoading: false,
            scrollBehavior: TimelineScrollBehavior.none,
            targetResponseId: null,
          );
        }
        
        // チャット完了をDeviceStatusProviderに通知（レスポンスなし時）
        if (!_isDisposed) {
          ref.read(deviceStatusProvider.notifier).endChatSession();
        }
      }
    } catch (e) {
      // debugPrint('Failed to send action query: $e');

      // プロバイダーがまだ有効かチェック
      if (_isDisposed) {
      // debugPrint('Provider disposed during action query, skipping state update');
        return;
      }

      // エラー時はユーザーメッセージを削除してローディング終了
      state = state.copyWith(
        timelineItems: state.timelineItems
            .where((item) => item.id != userMessageId)
            .toList(),
        isChatLoading: false,
        scrollBehavior: TimelineScrollBehavior.none,
        targetResponseId: null,
      );
      
      // タイムラインを保存
      _saveTimeline();
      
      // チャット完了をDeviceStatusProviderに通知（エラー時）
      try {
        if (!_isDisposed) {
          ref.read(deviceStatusProvider.notifier).endChatSession();
        }
      } catch (endSessionError) {
      // debugPrint('Error ending chat session: $endSessionError');
      }
    }
  }

  /// タイムラインアイテムを削除
  void removeTimelineItem(String itemId) {
    // スタックトレースを出力してどこから呼ばれているか確認
      // debugPrint('[TimelineProvider] removeTimelineItem called for: $itemId');
      // debugPrint('[TimelineProvider] Stack trace:');
    try {
      throw Exception('Stack trace');
    } catch (e, stackTrace) {
      // debugPrint(stackTrace.toString().split('\n').take(15).join('\n'));
    }
    
    final updatedItems = state.timelineItems
        .where((item) => item.id != itemId)
        .toList();
    state = state.copyWith(timelineItems: updatedItems);
      // debugPrint('[TimelineProvider] Removed timeline item: $itemId');
    
    // タイムラインを保存（ユーザーアクションなので即座に保存）
    _saveTimelineImmediate();
  }

  /// チャットメッセージID に避難所データを関連付ける
  void setShelterDataForChat(String chatId, List<dynamic> shelterData) {
    if (shelterData.isEmpty) return;
    
    final shelterDataId = 'shelter_${DateTime.now().millisecondsSinceEpoch}';
    
    // 避難所データをキャッシュに保存
    final newShelterDataCache = Map<String, Map<String, dynamic>>.from(state.shelterDataCache);
    newShelterDataCache[shelterDataId] = {
      'shelters': shelterData,
      'timestamp': DateTime.now().toIso8601String(),
    };
    
    // チャットIDから避難所データIDへのマッピングを保存
    final newChatToShelterMapping = Map<String, String>.from(state.chatIdToShelterDataId);
    newChatToShelterMapping[chatId] = shelterDataId;
    
    state = state.copyWith(
      shelterDataCache: newShelterDataCache,
      chatIdToShelterDataId: newChatToShelterMapping,
    );
    
    if (kDebugMode) {
      debugPrint('[TimelineProvider] Set shelter data for chat $chatId: ${shelterData.length} shelters');
    }
    
    // 避難所データも永続化
    _saveTimeline();
  }


  /// 完全リセット - 全てのタイムラインアイテムをクリア（設定リセット時使用）
  void clearAllTimelineItems() {
      // debugPrint('[TimelineProvider] === CLEARING ALL TIMELINE ITEMS ===');
      // debugPrint('[TimelineProvider] Current items count: ${state.timelineItems.length}');
    
    // ストリーミングを停止
    stopStreaming();
    
    // 全てのタイムラインアイテムをクリア
    final previousCount = state.timelineItems.length;
    state = state.copyWith(
      timelineItems: [],
      errorMessage: null,
      importantAlert: null,
      streamedSuggestions: [],
    );
    
    // ローカルストレージも同期してクリア（設定リセット時は即座に保存）
    _saveTimelineImmediate();
    
      // debugPrint('[TimelineProvider] ⚠️ TIMELINE CLEARED: $previousCount items removed');
  }

  /// ストリーミング機能の有効/無効を切り替え
  void toggleStreamingMode() {
    final newStreamingEnabled = !state.isStreamingEnabled;
    
    state = state.copyWith(isStreamingEnabled: newStreamingEnabled);
    
    if (!newStreamingEnabled) {
      // ストリーミング無効時は停止
      stopStreaming();
    }
  }

  /// ストリーミング提案取得を開始（無効化済み）
  Future<void> startStreaming() async {
    return; // ハートビート統合により無効化
  }



  /// ストリーミングを停止
  void stopStreaming() {
    _streamSubscription?.cancel();
    _streamSubscription = null;
    state = state.copyWith(isStreaming: false);
  }


  /// ストリームデータを TimelineItemModel に変換
  TimelineItemModel? _parseStreamedSuggestion(Map<String, dynamic> data) {
    try {
      final suggestionData = data['data'] ?? data;
      
      if (suggestionData['type'] == null) {
        return null;
      }

      final type = suggestionData['type'] as String;
      final id = '${type}_streamed_${DateTime.now().millisecondsSinceEpoch}';

      // サポートされている提案タイプをチェック
      const supportedTypes = {
        'welcome_message',
        'contact_registration_prompt',
        'contact_registration_reminder',
        'guide_recommendation',
        'app_feature_introduction',
        'hazard_map_prompt',
        'emergency_contact_setup',
        'low_battery_warning',
        // 'emergency_alert', // FCMからのみ処理
        // 'disaster_update', // FCMからのみ処理
        'disaster_news', // 情報提供のみ（アラートではない）
        'quiz_reminder',
        'safety_confirmation_sms_proposal',
        'immediate_safety_action',
        'evacuation_prompt',
        'official_info_check_prompt',
        'seasonal_warning',
        'emergency',
        // 'emergency_disaster_news', // FCMからのみ処理
        'emergency_guidance',
        'disaster_info', // 情報提供のみ（アラートではない）
        'evacuation_instruction',
        'location_based_info',
        'seasonal_alert',
        'app_feature_recommendation',
        'shelter_status_update',
        'shelter_info',
      };

      if (!supportedTypes.contains(type)) {
      // debugPrint('[TimelineProvider] Unsupported streamed suggestion type: $type');
        return null;
      }

      return TimelineItemModel.suggestion(
        id: id,
        suggestionType: type,
        content: suggestionData['content'] ?? '',
        actionData: suggestionData['action_data'],
        actionQuery: suggestionData['action_query'],
        actionDisplayText: suggestionData['action_display_text'],
        timestamp: DateTime.parse(
          suggestionData['created_at'] ?? DateTime.now().toIso8601String(),
        ),
      );
    } catch (e) {
      // debugPrint('[TimelineProvider] Failed to parse streamed suggestion: $e');
      return null;
    }
  }

  /// ストリーミング提案をメインタイムラインに統合
  void integrateStreamedSuggestions() {
    if (state.streamedSuggestions.isEmpty) return;

      // debugPrint('[TimelineProvider] Integrating ${state.streamedSuggestions.length} streamed suggestions');
    
    // 既存の提案を取得（内容ベースの重複チェック用）
    final existingSuggestions = state.timelineItems
        .where((item) => item.type == TimelineItemType.suggestion)
        .map((item) => item.when(
              alert: (_, __, ___, ____, _____) => null,
              chat: (_, __, ___, ____, _____) => null,
              chatWithAction: (_, __, ___, ____, _____, ______, _______) => null,
              suggestion: (id, suggestionType, timestamp, content, _____, ______, _______) => {
                'id': id,
                'type': suggestionType,
                'content': content,
                'timestamp': timestamp.toIso8601String(),
              },
            ))
        .where((item) => item != null)
        .cast<Map<String, String>>()
        .toList();

    final newSuggestions = state.streamedSuggestions.where((suggestion) {
      return suggestion.when(
        alert: (_, __, ___, ____, _____) => true,
        chat: (_, __, ___, ____, _____) => true,
        chatWithAction: (_, __, ___, ____, _____, ______, _______) => true,
        suggestion: (_, suggestionType, ___, content, ____, _____, ______) {
          return !_isDuplicateSuggestion(suggestionType, content, existingSuggestions);
        },
      );
    }).toList();

    if (newSuggestions.isNotEmpty) {
      state = state.copyWith(
        timelineItems: [...state.timelineItems, ...newSuggestions],
        streamedSuggestions: [], // クリア
      );
      
      _saveTimeline();
      // debugPrint('[TimelineProvider] Integrated ${newSuggestions.length} new suggestions');
    } else {
      // debugPrint('[TimelineProvider] No new suggestions to integrate (all duplicates)');
      state = state.copyWith(streamedSuggestions: []);
    }
  }

  /// ストリーミング提案をクリア
  void clearStreamedSuggestions() {
    state = state.copyWith(streamedSuggestions: []);
  }

  /// ハートビート統合SSE接続をトリガー
  Future<void> triggerSSEConnection() async {
      // debugPrint('[TimelineProvider] 🚀 Triggering SSE connection from heartbeat');
    
    try {
      // SSE機能は現在StreamingSuggestionsListで管理されているため、
      // そこにSSE開始を通知する必要がある
      // 
      // 注意: この実装はStreamingSuggestionsListに依存しているため、
      // より良いアプローチは、StreamingSuggestionsListがTimelineProviderの
      // 状態変更を監視することです
      
      // 状態を更新してSSE開始を示す
      state = state.copyWith(isStreaming: true);
      // debugPrint('[TimelineProvider] ✅ SSE trigger state updated');
      
      // SSE接続開始後、StreamingSuggestionsListが処理を開始したら
      // 3秒後に自動的にフラグをリセット（複数回のトリガーを防ぐため）
      // 1秒では短すぎてSSE接続が開始される前にリセットされる可能性がある
      Future.delayed(const Duration(seconds: 3), () {
        if (state.isStreaming) {
          state = state.copyWith(isStreaming: false);
      // debugPrint('[TimelineProvider] 🔄 SSE trigger state reset after delay');
        }
      });
      
    } catch (e) {
      // debugPrint('[TimelineProvider] ❌ Failed to trigger SSE connection: $e');
    }
  }

  /// プロバイダーが破棄される際の清掃
  void dispose() {
    _isDisposed = true;
    stopStreaming();
    _saveDebounceTimer?.cancel();
  }

  /// 重複提案チェック
  bool _isDuplicateSuggestion(String suggestionType, String content, List<Map<String, String>> existingSuggestions) {
    // すでに同じタイプの提案が存在する場合は重複と判定
    final isDuplicate = existingSuggestions.any((existing) => existing['type'] == suggestionType);
    
    if (isDuplicate) {
      // debugPrint('[TimelineProvider] 🚫 Duplicate suggestion filtered: $suggestionType already exists in timeline');
    }
    
    return isDuplicate;
  }

  /// Add a chat message to the timeline (used by voice chat)
  void addMessage(ChatMessage message) {
      // debugPrint('[TimelineProvider] Adding chat message from voice input');
    
    // Convert ChatMessage to TimelineItemModel
    final timelineItem = TimelineItemModel.chat(
      id: message.id,
      timestamp: message.timestamp,
      messageText: message.content,
      senderNickname: message.sender == MessageSender.user ? 'You' : 
                      message.sender == MessageSender.ai ? 'SafetyBee' : 'System',
      isOwnMessage: message.sender == MessageSender.user,
    );
    
    // Add to timeline
    state = state.copyWith(
      timelineItems: [...state.timelineItems, timelineItem],
    );
    
    // Save timeline（音声チャットメッセージは即座に保存）
    _saveTimelineImmediate();
    
    // Process any cards that came with the response
    final cards = message.metadata?['cards'] as List<dynamic>?;
    if (cards != null && cards.isNotEmpty) {
      _processGeneratedCards(cards, message.id);
    }
  }

  /// Process generated cards from chat response
  void _processGeneratedCards(List<dynamic> generatedCards, String messageId) {
    if (generatedCards.isEmpty) return;
    
      // debugPrint('[TimelineProvider] Processing ${generatedCards.length} generated cards from voice chat');
    
    // Current timeline items
    List<TimelineItemModel> updatedItems = [...state.timelineItems];
    
    // Filter shelter cards
    final shelterCards = generatedCards.where((card) {
      final isEvacuationType = 
        card['type'] == 'shelter_status_update' ||
        card['card_type'] == 'evacuation_info' ||
        card['type'] == 'shelter_location' ||
        card['type'] == 'shelter_info';
      
      if (!isEvacuationType) return false;
      
      final location = card['location'] as Map<String, dynamic>?;
      final data = card['data'] as Map<String, dynamic>?;
      
      final hasLatitude = location?['latitude'] != null || 
                         data?['latitude'] != null ||
                         card['shelter_latitude'] != null;
      final hasLongitude = location?['longitude'] != null || 
                           data?['longitude'] != null ||
                           card['shelter_longitude'] != null;
      
      return hasLatitude && hasLongitude;
    }).toList();
    
    // Process shelter cards
    if (shelterCards.isNotEmpty) {
      // Use cached location instead of fetching new location
      final currentLocation = ref.read(deviceStatusProvider).currentLocation;
      final shelterData = {
        'shelters': shelterCards,
        'userLocation': currentLocation != null
            ? {
                'latitude': currentLocation.latitude,
                'longitude': currentLocation.longitude,
              }
            : null,
      };
      
      final shelterMapId = 'shelter_map_${messageId}';
      final updatedCache = {...state.shelterDataCache};
      updatedCache[shelterMapId] = shelterData;
      
      state = state.copyWith(shelterDataCache: updatedCache);
      
      final updatedMapping = {...state.chatIdToShelterDataId};
      updatedMapping[messageId] = shelterMapId;
      state = state.copyWith(chatIdToShelterDataId: updatedMapping);
      
      _saveTimelineImmediate();
    }
    
    // Process hazard map cards
    final hazardMapCards = generatedCards
        .where((card) => card['card_type'] == 'hazard_map_info' || card['card_type'] == 'hazard_map_viewer')
        .toList();
    
    if (hazardMapCards.isNotEmpty) {
      for (final hazardCard in hazardMapCards) {
        final actionButtons = hazardCard['action_buttons'] as List<dynamic>?;
        
        if (actionButtons != null && actionButtons.isNotEmpty) {
          for (int i = 0; i < actionButtons.length; i++) {
            final button = actionButtons[i] as Map<String, dynamic>;
            final hazardMapId = 'hazard_map_${DateTime.now().millisecondsSinceEpoch}_${hazardCard['card_id']}_$i';
            
            final hazardMapItem = TimelineItemModel.suggestion(
              id: hazardMapId,
              suggestionType: 'hazard_map_url',
              content: hazardCard['title'] ?? 'ハザードマップ',
              actionData: {
                'action': 'open_hazard_map',
                'url': button['url'],
                'title': button['label'] ?? hazardCard['title'],
                'description': hazardCard['description'],
              },
              actionQuery: null,
              actionDisplayText: button['label'] ?? 'ハザードマップを開く',
              timestamp: DateTime.now(),
            );
            
            updatedItems.add(hazardMapItem);
          }
        } else {
          final hazardMapId = 'hazard_map_${DateTime.now().millisecondsSinceEpoch}_${hazardCard['card_id']}';
          final hazardMapItem = TimelineItemModel.suggestion(
            id: hazardMapId,
            suggestionType: 'hazard_map_url',
            content: hazardCard['title'] ?? 'ハザードマップ',
            actionData: {
              'action': 'open_hazard_map',
              'url': hazardCard['action_url'],
              'title': hazardCard['title'],
              'description': hazardCard['description'],
            },
            actionQuery: null,
            actionDisplayText: 'ハザードマップを開く',
            timestamp: DateTime.now(),
          );
          
          updatedItems.add(hazardMapItem);
        }
      }
    }
    
    // Update state with new items
    if (updatedItems.length > state.timelineItems.length) {
      state = state.copyWith(timelineItems: updatedItems);
      _saveTimelineImmediate();
    }
  }

  /// 内容の類似度チェック
  bool _isSimilarContent(String existing, String newContent) {
    // 空文字列の場合はタイプのみで判定
    if (existing.isEmpty || newContent.isEmpty) {
      return existing == newContent;
    }

    // 完全一致の場合は重複
    if (existing == newContent) {
      return true;
    }

    // 長さが大きく異なる場合は別の内容と判定
    if ((existing.length - newContent.length).abs() > existing.length * 0.5) {
      return false;
    }

    // 単語ベースの類似度チェック（簡易版）
    final existingWords = existing.toLowerCase().split(RegExp(r'[\s\p{P}]+'));
    final newWords = newContent.toLowerCase().split(RegExp(r'[\s\p{P}]+'));
    
    // 共通単語の割合を計算
    final commonWords = existingWords.where((word) => newWords.contains(word)).length;
    final maxWords = [existingWords.length, newWords.length].reduce((a, b) => a > b ? a : b);
    
    // 70%以上の単語が共通している場合は類似と判定
    return maxWords > 0 && (commonWords / maxWords) >= 0.7;
  }

  /// アラートコンテンツのローカライズ
  Map<String, String> _getLocalizedAlertContent(String alertType, String languageCode) {
    // アラートタイプに基づいてローカライズされたタイトルとメッセージを返す
    final localizedContent = <String, String>{};
    
    switch (alertType) {
      case 'earthquake':
        localizedContent['title'] = _getLocalizedAlertTitle('earthquake', languageCode);
        localizedContent['message'] = _getLocalizedAlertMessage('earthquake', languageCode);
        break;
      case 'tsunami':
        localizedContent['title'] = _getLocalizedAlertTitle('tsunami', languageCode);
        localizedContent['message'] = _getLocalizedAlertMessage('tsunami', languageCode);
        break;
      case 'heavy_rain':
        localizedContent['title'] = _getLocalizedAlertTitle('heavy_rain', languageCode);
        localizedContent['message'] = _getLocalizedAlertMessage('heavy_rain', languageCode);
        break;
      case 'fire':
        localizedContent['title'] = _getLocalizedAlertTitle('fire', languageCode);
        localizedContent['message'] = _getLocalizedAlertMessage('fire', languageCode);
        break;
      default:
        localizedContent['title'] = _getLocalizedAlertTitle('emergency', languageCode);
        localizedContent['message'] = _getLocalizedAlertMessage('emergency', languageCode);
        break;
    }
    
    return localizedContent;
  }

  String _getLocalizedAlertTitle(String alertType, String languageCode) {
    // ローカライズされたタイトルを返す
    final titles = {
      'earthquake': {
        'ja': '🚨 緊急地震速報（テスト）',
        'en': '🚨 Earthquake Alert (Test)',
        'zh': '🚨 紧急地震速报（测试）',
        'zh_CN': '🚨 紧急地震速报（测试）',
        'zh_TW': '🚨 緊急地震速報（測試）',
        'ko': '🚨 긴급 지진 속보 (테스트)',
        'es': '🚨 Alerta de Terremoto (Prueba)',
        'fr': '🚨 Alerte Séisme (Test)',
        'de': '🚨 Erdbebenwarnung (Test)',
        'it': '🚨 Allerta Terremoto (Test)',
        'pt': '🚨 Alerta de Terremoto (Teste)',
        'ru': '🚨 Экстренное предупреждение о землетрясении (Тест)',
      },
      'tsunami': {
        'ja': '🌊 津波警報（テスト）',
        'en': '🌊 Tsunami Warning (Test)',
        'zh': '🌊 海啸警报（测试）',
        'zh_CN': '🌊 海啸警报（测试）',
        'zh_TW': '🌊 海嘯警報（測試）',
        'ko': '🌊 쓰나미 경보 (테스트)',
        'es': '🌊 Alerta de Tsunami (Prueba)',
        'fr': '🌊 Alerte Tsunami (Test)',
        'de': '🌊 Tsunami-Warnung (Test)',
        'it': '🌊 Allerta Tsunami (Test)',
        'pt': '🌊 Alerta de Tsunami (Teste)',
        'ru': '🌊 Предупреждение о цунами (Тест)',
      },
      'heavy_rain': {
        'ja': '🌧️ 大雨特別警報（テスト）',
        'en': '🌧️ Heavy Rain Warning (Test)',
        'zh': '🌧️ 暴雨特别警报（测试）',
        'zh_CN': '🌧️ 暴雨特别警报（测试）',
        'zh_TW': '🌧️ 大雨特別警報（測試）',
        'ko': '🌧️ 호우 특보 (테스트)',
        'es': '🌧️ Alerta de Lluvia Intensa (Prueba)',
        'fr': '🌧️ Alerte Fortes Pluies (Test)',
        'de': '🌧️ Starkregenwarnung (Test)',
        'it': '🌧️ Allerta Pioggia Intensa (Test)',
        'pt': '🌧️ Alerta de Chuva Forte (Teste)',
        'ru': '🌧️ Предупреждение о сильном дожде (Тест)',
      },
      'fire': {
        'ja': '🔥 火災警報（テスト）',
        'en': '🔥 Fire Alert (Test)',
        'zh': '🔥 火灾警报（测试）',
        'zh_CN': '🔥 火灾警报（测试）',
        'zh_TW': '🔥 火災警報（測試）',
        'ko': '🔥 화재 경보 (테스트)',
        'es': '🔥 Alerta de Incendio (Prueba)',
        'fr': '🔥 Alerte Incendie (Test)',
        'de': '🔥 Feueralarm (Test)',
        'it': '🔥 Allerta Incendio (Test)',
        'pt': '🔥 Alerta de Incêndio (Teste)',
        'ru': '🔥 Пожарная тревога (Тест)',
      },
      'emergency': {
        'ja': '🚨 緊急アラート（テスト）',
        'en': '🚨 Emergency Alert (Test)',
        'zh': '🚨 紧急警报（测试）',
        'zh_CN': '🚨 紧急警报（测试）',
        'zh_TW': '🚨 緊急警報（測試）',
        'ko': '🚨 긴급 경보 (테스트)',
        'es': '🚨 Alerta de Emergencia (Prueba)',
        'fr': '🚨 Alerte d\'Urgence (Test)',
        'de': '🚨 Notfallwarnung (Test)',
        'it': '🚨 Allerta di Emergenza (Test)',
        'pt': '🚨 Alerta de Emergência (Teste)',
        'ru': '🚨 Экстренное предупреждение (Тест)',
      },
    };
    
    return titles[alertType]?[languageCode] ?? titles[alertType]?['ja'] ?? '🚨 緊急アラート（テスト）';
  }

  String _getLocalizedAlertMessage(String alertType, String languageCode) {
    // ローカライズされたメッセージを返す
    final messages = {
      'earthquake': {
        'ja': 'これはテスト用の緊急地震速報です。強い揺れに警戒してください。（テスト）',
        'en': 'This is a test earthquake alert. Please take cover from strong shaking. (Test)',
        'zh': '这是测试用的紧急地震速报。请警惕强烈摇晃。（测试）',
        'zh_CN': '这是测试用的紧急地震速报。请警惕强烈摇晃。（测试）',
        'zh_TW': '這是測試用的緊急地震速報。請警惕強烈搖晃。（測試）',
        'ko': '이것은 테스트용 긴급 지진 속보입니다. 강한 흔들림에 주의하세요. (테스트)',
        'es': 'Esta es una alerta de terremoto de prueba. Protéjase de las sacudidas fuertes. (Prueba)',
        'fr': 'Ceci est une alerte sismique de test. Abritez-vous des fortes secousses. (Test)',
        'de': 'Dies ist eine Test-Erdbebenwarnung. Schützen Sie sich vor starken Erschütterungen. (Test)',
        'it': 'Questo è un test di allerta terremoto. Proteggersi dalle forti scosse. (Test)',
        'pt': 'Este é um alerta de terremoto de teste. Proteja-se de tremores fortes. (Teste)',
        'ru': 'Это тестовое предупреждение о землетрясении. Укройтесь от сильных толчков. (Тест)',
      },
      'tsunami': {
        'ja': 'これはテスト用の津波警報です。高台に避難してください。（テスト）',
        'en': 'This is a test tsunami warning. Please evacuate to higher ground. (Test)',
        'zh': '这是测试用的海啸警报。请避难到高地。（测试）',
        'zh_CN': '这是测试用的海啸警报。请避难到高地。（测试）',
        'zh_TW': '這是測試用的海嘯警報。請避難到高地。（測試）',
        'ko': '이것은 테스트용 쓰나미 경보입니다. 높은 곳으로 대피하세요. (테스트)',
        'es': 'Esta es una alerta de tsunami de prueba. Evacúe a terrenos elevados. (Prueba)',
        'fr': 'Ceci est une alerte tsunami de test. Évacuez vers les hauteurs. (Test)',
        'de': 'Dies ist eine Test-Tsunami-Warnung. Evakuieren Sie auf höher gelegenes Gelände. (Test)',
        'it': 'Questo è un test di allerta tsunami. Evacuare verso luoghi elevati. (Test)',
        'pt': 'Este é um alerta de tsunami de teste. Evacue para terrenos elevados. (Teste)',
        'ru': 'Это тестовое предупреждение о цунами. Эвакуируйтесь на возвышенность. (Тест)',
      },
      'heavy_rain': {
        'ja': 'これはテスト用の大雨特別警報です。命を守る行動をとってください。（テスト）',
        'en': 'This is a test heavy rain warning. Please take life-saving actions. (Test)',
        'zh': '这是测试用的暴雨特别警报。请采取保护生命的行动。（测试）',
        'zh_CN': '这是测试用的暴雨特别警报。请采取保护生命的行动。（测试）',
        'zh_TW': '這是測試用的大雨特別警報。請採取保護生命的行動。（測試）',
        'ko': '이것은 테스트용 호우 특보입니다. 생명을 지키는 행동을 취하세요. (테스트)',
        'es': 'Esta es una alerta de lluvia intensa de prueba. Tome acciones para salvar su vida. (Prueba)',
        'fr': 'Ceci est une alerte de fortes pluies de test. Prenez des mesures pour sauver votre vie. (Test)',
        'de': 'Dies ist eine Test-Starkregenwarnung. Ergreifen Sie lebensrettende Maßnahmen. (Test)',
        'it': 'Questo è un test di allerta pioggia intensa. Prendere azioni salvavita. (Test)',
        'pt': 'Este é um alerta de chuva forte de teste. Tome ações para salvar sua vida. (Teste)',
        'ru': 'Это тестовое предупреждение о сильном дожде. Примите меры для спасения жизни. (Тест)',
      },
      'fire': {
        'ja': 'これはテスト用の火災警報です。速やかに避難してください。（テスト）',
        'en': 'This is a test fire alert. Please evacuate immediately. (Test)',
        'zh': '这是测试用的火灾警报。请迅速避难。（测试）',
        'zh_CN': '这是测试用的火灾警报。请迅速避难。（测试）',
        'zh_TW': '這是測試用的火災警報。請迅速避難。（測試）',
        'ko': '이것은 테스트용 화재 경보입니다. 신속히 대피하세요. (테스트)',
        'es': 'Esta es una alerta de incendio de prueba. Evacúe inmediatamente. (Prueba)',
        'fr': 'Ceci est une alerte incendie de test. Évacuez immédiatement. (Test)',
        'de': 'Dies ist ein Test-Feueralarm. Evakuieren Sie sofort. (Test)',
        'it': 'Questo è un test di allerta incendio. Evacuare immediatamente. (Test)',
        'pt': 'Este é um alerta de incêndio de teste. Evacue imediatamente. (Teste)',
        'ru': 'Это тестовая пожарная тревога. Немедленно эвакуируйтесь. (Тест)',
      },
      'emergency': {
        'ja': 'これはデバッグ機能から発報されたテストアラートです。',
        'en': 'This is a test alert triggered from debug features.',
        'zh': '这是从调试功能触发的测试警报。',
        'zh_CN': '这是从调试功能触发的测试警报。',
        'zh_TW': '這是從調試功能觸發的測試警報。',
        'ko': '이것은 디버그 기능에서 발령된 테스트 경보입니다.',
        'es': 'Esta es una alerta de prueba activada desde funciones de depuración.',
        'fr': 'Ceci est une alerte de test déclenchée depuis les fonctions de débogage.',
        'de': 'Dies ist ein Testalarm, der von Debug-Funktionen ausgelöst wurde.',
        'it': 'Questo è un avviso di test attivato dalle funzioni di debug.',
        'pt': 'Este é um alerta de teste acionado a partir de recursos de depuração.',
        'ru': 'Это тестовое предупреждение, вызванное из отладочных функций.',
      },
    };
    
    return messages[alertType]?[languageCode] ?? messages[alertType]?['ja'] ?? 'これはテストアラートです。';
  }

  /// スクロール動作をリセット
  void resetScrollBehavior() {
    state = state.copyWith(
      scrollBehavior: TimelineScrollBehavior.none,
      targetResponseId: null,
    );
  }

  /// 避難所データのハッシュを生成（データベースキャッシュキー用）
  String _generateShelterDataHash(Map<String, dynamic> shelterData) {
    // 避難所データの本質的な内容からハッシュを生成
    final shelters = shelterData['shelters'] as List<dynamic>? ?? [];
    final userLocation = shelterData['userLocation'] as Map<String, dynamic>?;
    
    // 避難所IDと位置情報からハッシュ値を計算
    final shelterIds = shelters.map((shelter) => 
      '${shelter['id'] ?? ''}_${shelter['name'] ?? ''}'
    ).join('|');
    
    final locationKey = userLocation != null 
      ? '${userLocation['latitude']}_${userLocation['longitude']}'
      : 'no_location';
    
    // 文字列ハッシュを計算
    final combined = '${shelterIds}_$locationKey';
    return combined.hashCode.abs().toString();
  }

  /// 避難所データを事前処理（重複処理の削除）
  List<Map<String, dynamic>> _preprocessShelterData(List<dynamic> shelterCards) {
    return shelterCards.map((shelterData) {
      // バックエンドデータ構造に対応した変換（統一処理）
      final locationData = shelterData['location'] as Map<String, dynamic>?;
      final dataField = shelterData['data'] as Map<String, dynamic>?;
      final latitude = locationData?['latitude'] as num? ?? 
                       dataField?['latitude'] as num? ??
                       shelterData['shelter_latitude'] as num?;
      final longitude = locationData?['longitude'] as num? ??
                        dataField?['longitude'] as num? ??
                        shelterData['shelter_longitude'] as num?;
      
      // 統一されたフォーマットで返却
      return {
        'id': shelterData['card_id'] ?? shelterData['id'] ?? 'unknown',
        'name': shelterData['title'] ?? shelterData['name'] ?? shelterData['shelter_name'] ?? 'Unknown Shelter',
        'status': dataField?['status'] ?? shelterData['status'] ?? 'Available',
        'latitude': latitude?.toDouble(),
        'longitude': longitude?.toDouble(),
        'address': shelterData['address'] ?? dataField?['address'] ?? shelterData['shelter_address'] ?? '',
        'shelter_type': dataField?['shelter_type'] ?? shelterData['shelter_type'] ?? '',
        'capacity': dataField?['capacity'] ?? shelterData['capacity'] ?? 0,
        'distance_km': dataField?['distance_km'] ?? shelterData['distance_km'] ?? 0.0,
      };
    }).toList();
  }

  /// 緊急連絡先数を取得
  Future<int> _getEmergencyContactsCount() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // 緊急連絡先のキーを確認
      final contactsStringList = prefs.getStringList('app_emergency_contacts_v2');
      
      if (contactsStringList == null || contactsStringList.isEmpty) {
        return 0;
      }
      
      return contactsStringList.length;
    } catch (e) {
      // debugPrint('[TimelineProvider] Error getting emergency contacts count: $e');
      return 0;
    }
  }

  /// アイテムのアクション状態をクリア（SMS確認フォームなど）
  void clearItemAction(String itemId) {
    final updatedItems = state.timelineItems.map<TimelineItemModel>((item) {
      if (item.id == itemId && item is ChatWithActionTimelineItem) {
        // アクション状態をクリアした新しいアイテムを作成
        return TimelineItemModel.chat(
          id: item.id,
          timestamp: item.timestamp,
          messageText: item.messageText,
          senderNickname: item.senderNickname,
          isOwnMessage: item.isOwnMessage,
        );
      }
      return item;
    }).toList();

    state = state.copyWith(timelineItems: updatedItems);
    _saveTimeline(); // 変更をローカルストレージに保存
  }
  
  /// アクションタイプに基づいてアクションクエリを生成
  String? _generateActionQuery(String? actionType) {
    if (actionType == null) return null;
    
    switch (actionType) {
      case 'check_disasters':
        return '現在の災害情報を教えて';
      case 'view_alerts':
        return '災害警報を確認したい';
      case 'find_shelters':
        return '近くの避難所を教えて';
      case 'evacuation_guide':
        return '避難ガイダンスを知りたい';
      case 'disaster_info':
        return '災害情報を教えて';
      case 'safety_guide':
        return '防災ガイドを見たい';
      default:
        return '詳細情報を教えて';
    }
  }
}
