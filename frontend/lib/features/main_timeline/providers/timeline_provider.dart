import 'dart:async'; // StreamSubscriptionç”¨
import 'package:dio/dio.dart'; // CancelTokenç”¨
import 'package:flutter/foundation.dart'; // for debugPrint
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:frontend/features/settings/providers/settings_provider.dart';
import 'package:frontend/core/models/alert_model.dart';
// Removed duplicate: chat_message_model.dart - using chat_message.dart instead
import 'package:frontend/core/models/timeline_item_model.dart';
import 'package:frontend/core/providers/service_providers.dart';
import 'package:frontend/core/services/api_service.dart'; // Import ApiService
import 'package:frontend/features/main_timeline/providers/device_status_provider.dart';
import 'package:frontend/core/models/chat_message.dart'; // For ChatMessage and MessageSender
import 'package:riverpod_annotation/riverpod_annotation.dart'; // For @Riverpod
import 'package:tuple/tuple.dart'; // For Tuple2
import 'package:google_maps_flutter/google_maps_flutter.dart'; // For LatLng
import 'package:frontend/core/services/timeline_storage_service.dart';
import 'package:frontend/core/models/location_model.dart';
import 'package:shared_preferences/shared_preferences.dart';

part 'timeline_provider.freezed.dart';
part 'timeline_provider.g.dart';

enum TimelineScrollBehavior {
  none,           // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ãªã„
  toBottom,       // æœ€ä¸‹éƒ¨ã¸ï¼ˆãƒãƒ£ãƒƒãƒˆè³ªå•æ™‚ï¼‰
  toResponse,     // ç‰¹å®šã®å›ç­”ã¸ï¼ˆã‚«ãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯æ™‚ï¼‰
  toAlert,        // ç½å®³ã‚¢ãƒ©ãƒ¼ãƒˆã¸ï¼ˆã‚¢ãƒ©ãƒ¼ãƒˆå—ä¿¡æ™‚ï¼‰
}

@freezed
class TimelineState with _$TimelineState {
  const factory TimelineState({
    @Default(<TimelineItemModel>[]) List<TimelineItemModel> timelineItems,
    @Default(false) bool isLoading,
    @Default(false) bool isChatLoading, // ãƒãƒ£ãƒƒãƒˆé€ä¿¡æ™‚ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å°‚ç”¨
    @Default(false) bool isEmergencyLoading, // ç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å°‚ç”¨
    @Default(true) bool hasMoreItems,
    String? errorMessage,
    AlertModel? importantAlert,
    @Default('') String currentChatInput,
    @Default(true) bool isStreamingEnabled, // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°æ©Ÿèƒ½ã®æœ‰åŠ¹/ç„¡åŠ¹
    @Default(false) bool isStreaming, // ç¾åœ¨ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ä¸­ã‹ã©ã†ã‹
    @Default(<TimelineItemModel>[]) List<TimelineItemModel> streamedSuggestions, // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ä¸­ã®ææ¡ˆ
    @Default({}) Map<String, Map<String, dynamic>> shelterDataCache, // é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    @Default({}) Map<String, String> chatIdToShelterDataId, // ãƒãƒ£ãƒƒãƒˆIDã‹ã‚‰é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿IDã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°
    @Default('') String chatLoadingStatus, // è©³ç´°ãªãƒãƒ£ãƒƒãƒˆãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹
    @Default(TimelineScrollBehavior.none) TimelineScrollBehavior scrollBehavior, // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‹•ä½œåˆ¶å¾¡
    String? targetResponseId, // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å…ˆã®å›ç­”ID
    String? targetAlertId, // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å…ˆã®ã‚¢ãƒ©ãƒ¼ãƒˆID
    CancelToken? chatCancelToken, // ãƒãƒ£ãƒƒãƒˆä¸­æ­¢ç”¨ãƒˆãƒ¼ã‚¯ãƒ³
  }) = _TimelineState;
}

@Riverpod(keepAlive: true)
class Timeline extends _$Timeline {
  // Extends _$Timeline (generated by Riverpod Generator)
  StreamSubscription? _streamSubscription;
  Timer? _saveDebounceTimer;
  bool _isDisposed = false;
  bool _isLoadingSavedTimeline = false;
  
  @override
  TimelineState build() {
    // This is the initial state
    debugPrint('[TimelineProvider] build() called, starting with isLoading: true');
    
    // ãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰å¯¾ç­–: ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å¾©å…ƒã‚’è©¦ã¿ã‚‹
    Future.microtask(() async {
      try {
        final savedItems = await TimelineStorageService.loadTimelineItems();
        final savedShelterCache = await TimelineStorageService.loadShelterDataCache();
        final savedChatToShelterMapping = await TimelineStorageService.loadChatToShelterMapping();
        
        if (savedItems.isNotEmpty && !_isDisposed) {
          // ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯å³åº§ã«å¾©å…ƒï¼ˆãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤ºãªã—ï¼‰
          state = state.copyWith(
            timelineItems: savedItems,
            shelterDataCache: savedShelterCache,
            chatIdToShelterDataId: savedChatToShelterMapping,
            isLoading: false,
          );
        } else {
          // ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯é€šå¸¸ã®åˆæœŸåŒ–
          _loadSavedTimeline();
        }
      } catch (e) {
        debugPrint('[TimelineProvider] Error in hot reload recovery: $e');
        _loadSavedTimeline();
      }
    });
    
    // è¨­å®šãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã‹ã‚‰ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³å–å¾—ã‚’å®Ÿè¡Œ
    ref.listen(settingsProvider, (previous, next) {
      // Check for language change specifically
      final previousLanguage = previous?.currentUserSettings?.languageCode;
      final nextLanguage = next.currentUserSettings?.languageCode;
      final languageChanged =
          previousLanguage != nextLanguage && nextLanguage != null;

      // è¨€èªãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã¯å¼·åˆ¶ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
      if (next.currentUserSettings != null && !next.isLoading) {
        if (languageChanged && !state.isLoading) {
          // è¨€èªå¤‰æ›´æ™‚ã¯forceRefreshForLanguageChangeã‚’å‘¼ã³å‡ºã™
          Future.microtask(() => forceRefreshForLanguageChange());
        }
      }
    });

    return const TimelineState(
      isStreamingEnabled: true, // SSEã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæœ‰åŠ¹åŒ–
      isLoading: true, // Show loading animation on startup
    ); // Return the initial state
  }

  // Helper to access ApiService
  ApiService get _apiService => ref.read(apiServiceProvider);

  /// ä¿å­˜ã•ã‚ŒãŸã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚’èª­ã¿è¾¼ã‚€
  Future<void> _loadSavedTimeline() async {
    // Prevent multiple simultaneous loads
    if (_isLoadingSavedTimeline) {
      print('[TimelineProvider] Already loading saved timeline, skipping');
      return;
    }
    
    _isLoadingSavedTimeline = true;
    
    try {
      print('[TimelineProvider] Starting _loadSavedTimeline, isLoading: ${state.isLoading}');
      
      // Start a timer to ensure minimum loading duration (2 seconds for better visibility)
      final minimumLoadingFuture = Future.delayed(const Duration(milliseconds: 2000));
      
      // Uncomment the following line to test loading animation
      // await TimelineStorageService.clearAllData();
      
      final savedItems = await TimelineStorageService.loadTimelineItems();
      final savedShelterCache = await TimelineStorageService.loadShelterDataCache();
      final savedChatToShelterMapping = await TimelineStorageService.loadChatToShelterMapping();
      
      // Wait for minimum loading duration to complete
      await minimumLoadingFuture;
      
      print('[TimelineProvider] Minimum loading duration complete, isLoading: ${state.isLoading}');
      
      // Check if the provider is still active before updating state
      if (_isDisposed) {
        print('[TimelineProvider] Provider disposed, not updating state');
        return;
      }
      
      if (savedItems.isNotEmpty) {
        // å¤ã„ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        final cleanedItems = await TimelineStorageService.cleanupOldItems(savedItems);
        
        if (cleanedItems.isNotEmpty) {
          state = state.copyWith(
            timelineItems: cleanedItems,
            shelterDataCache: savedShelterCache,
            chatIdToShelterDataId: savedChatToShelterMapping,
            isLoading: false, // Turn off loading after loading saved items
          );
        } else {
          // All items were cleaned up, just turn off loading
          state = state.copyWith(isLoading: false);
        }
      } else if (savedShelterCache.isNotEmpty || savedChatToShelterMapping.isNotEmpty) {
        // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ãŒãªãã¦ã‚‚é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯å¾©å…ƒ
        state = state.copyWith(
          shelterDataCache: savedShelterCache,
          chatIdToShelterDataId: savedChatToShelterMapping,
          isLoading: false, // Turn off loading even when no timeline items
        );
      } else {
        // No saved data at all, just turn off loading
        debugPrint('[TimelineProvider] No saved data, setting isLoading to false');
        state = state.copyWith(isLoading: false);
      }
    } catch (e) {
      debugPrint('[TimelineProvider] Error loading saved timeline: $e');
      // Also turn off loading on error
      state = state.copyWith(isLoading: false);
    } finally {
      _isLoadingSavedTimeline = false;
    }
  }

  /// ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä¿å­˜ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ä»˜ãï¼‰
  void _saveTimeline() {
    // æ—¢å­˜ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
    _saveDebounceTimer?.cancel();
    
    // 300mså¾Œã«ä¿å­˜å®Ÿè¡Œï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼‰
    _saveDebounceTimer = Timer(const Duration(milliseconds: 300), () {
      _executeSave();
    });
  }

  /// å³åº§ã«ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚’ä¿å­˜ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ãªã—ï¼‰
  void _saveTimelineImmediate() {
    _saveDebounceTimer?.cancel();
    _executeSave();
  }

  /// å®Ÿéš›ã®ä¿å­˜å‡¦ç†
  void _executeSave() {
    try {
      // éåŒæœŸã§ä¿å­˜ï¼ˆUIã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ï¼‰
      Future.microtask(() async {
        await TimelineStorageService.saveTimelineItems(state.timelineItems);
        await TimelineStorageService.saveShelterDataCache(state.shelterDataCache);
        await TimelineStorageService.saveChatToShelterMapping(state.chatIdToShelterDataId);
      }).catchError((e) {
      // debugPrint('[TimelineProvider] Error saving timeline: $e');
      });
    } catch (e) {
      // debugPrint('[TimelineProvider] Error initiating timeline save: $e');
    }
  }

  /// æ‰‹å‹•ã§ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³å–å¾—ã‚’ãƒˆãƒªã‚¬ãƒ¼
  Future<void> refreshTimeline() async {
    // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã®ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã¯DeviceStatusProviderã®ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆã§å‡¦ç†ã•ã‚Œã‚‹
    try {
      if (ref.exists(deviceStatusProvider)) {
        await ref.read(deviceStatusProvider.notifier).sendImmediateHeartbeat();
      }
    } catch (e) {
      // debugPrint('[TimelineProvider] Failed to trigger immediate heartbeat: $e');
    }
  }

  /// ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ 
  void addTimelineItem(TimelineItemModel item) {
    if (kDebugMode) {
      print('[TimelineProvider] Adding item: ${item.id}, type: ${item.type}');
      print('[TimelineProvider] Total items before: ${state.timelineItems.length}');
    }
    
    state = state.copyWith(
      timelineItems: [...state.timelineItems, item],
      scrollBehavior: TimelineScrollBehavior.toBottom,
    );
    
    if (kDebugMode) {
      print('[TimelineProvider] Total items after: ${state.timelineItems.length}');
    }
    
    _saveTimeline();
  }

  /// è¨€èªè¨­å®šå¤‰æ›´æ™‚ã«ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚’å¼·åˆ¶ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
  Future<void> forceRefreshForLanguageChange() async {
    // Clear current timeline first
    state = state.copyWith(timelineItems: [], errorMessage: null);

    // DeviceStatusProviderã«å³åº§ã«ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆé€ä¿¡ã‚’è¦æ±‚
    try {
      if (ref.exists(deviceStatusProvider)) {
        await ref.read(deviceStatusProvider.notifier).sendImmediateHeartbeat();
      }
    } catch (e) {
      // debugPrint('[TimelineProvider] Failed to send immediate heartbeat: $e');
    }
  }


  Future<void> fetchMoreItems() async {
    if (state.isLoading || !state.hasMoreItems) return;

    state = state.copyWith(isLoading: true);
    try {
      String? actualLastItemId;
      if (state.timelineItems.isNotEmpty) {
        // Accessing the wrapped data correctly for id
        actualLastItemId = state.timelineItems.last.when(
          alert: (id, timestamp, severity, title, message) => id,
          suggestion: (id, suggestionType, timestamp, content, actionData, actionQuery, actionDisplayText) => id,
          chat: (id, timestamp, messageText, senderNickname, isOwnMessage) => id,
          chatWithAction: (id, timestamp, messageText, senderNickname, isOwnMessage, requiresAction, actionData) => id,
        );
      }

      if (actualLastItemId == null && state.timelineItems.isNotEmpty) {
        state = state.copyWith(isLoading: false, hasMoreItems: false);
        return;
      }
      final newItems = await _apiService.getMoreTimelineItems(
        actualLastItemId!,
      );
      state = state.copyWith(
        timelineItems: [...state.timelineItems, ...newItems],
        isLoading: false,
        hasMoreItems: newItems.isNotEmpty,
      );
    } catch (e) {
      state = state.copyWith(isLoading: false, errorMessage: e.toString());
    }
  }

  void updateChatInput(String input) {
    state = state.copyWith(currentChatInput: input);
  }

  void cancelChatMessage() {
    final cancelToken = state.chatCancelToken;
    if (cancelToken != null && !cancelToken.isCancelled) {
      cancelToken.cancel('User cancelled chat message');
    }
    
    state = state.copyWith(
      isChatLoading: false,
      chatLoadingStatus: '',
      chatCancelToken: null,
    );
  }

  Future<void> sendChatMessage(String messageText) async {
    if (messageText.isEmpty) return;

    // Create cancel token for this chat request
    final cancelToken = CancelToken();

    // Set chat loading state with detailed status (scrollBehaviorã¯å¾Œã§è¨­å®š)
    state = state.copyWith(
      isChatLoading: true,
      chatLoadingStatus: 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æº–å‚™ä¸­...',
      chatCancelToken: cancelToken,
    );

    final tempId = DateTime.now().millisecondsSinceEpoch.toString();
    // Directly create TimelineItemModel without intermediate ChatMessageModel
    final tempTimelineItem = TimelineItemModel.chat(
      id: tempId,
      timestamp: DateTime.now(),
      messageText: messageText,
      senderNickname: 'You',
      isOwnMessage: true,
    );

    try {
      // Update status
      state = state.copyWith(chatLoadingStatus: 'ãƒ‡ãƒã‚¤ã‚¹æƒ…å ±ã‚’å–å¾—ä¸­...');
      
      final deviceId = await ref
          .read(deviceStatusProvider.notifier)
          .getDeviceId();

      // è¨€èªã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ï¼ˆLocalStorageã‹ã‚‰ç›´æ¥èª­ã¿è¾¼ã¿ï¼‰
      String language = 'ja'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
      try {
        final localStorage = ref.read(localStorageServiceProvider);
        final directSettings = await localStorage.loadUserSettings();
        if (directSettings != null && directSettings.languageCode.isNotEmpty) {
          language = directSettings.languageCode;
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šSettingsProviderã‚’ç¢ºèª
          final settingsState = ref.read(settingsProvider);
          if (!settingsState.isLoading && settingsState.currentUserSettings != null) {
            language = settingsState.currentUserSettings!.languageCode;
          }
        }
      } catch (e) {
      // debugPrint('[TimelineProvider] Failed to load language settings: $e');
      }
      
      // debugPrint('[TimelineProvider] Using language for chat: $language');

      // Update status
      state = state.copyWith(chatLoadingStatus: 'ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—ä¸­...');

      // ä¸¦åˆ—å‡¦ç†ã§å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      final results = await Future.wait([
        // ãƒãƒ£ãƒƒãƒˆå±¥æ­´ã®æ§‹ç¯‰
        Future(() {
          return state.timelineItems
              .where((item) => item.type == TimelineItemType.chat)
              .take(10)
              .map(
                (item) => item.when(
                  alert: (_, __, ___, ____, _____) => null,
                  suggestion:
                      (
                        _,
                        __,
                        ___,
                        ____,
                        _____,
                        ______,
                        _______,
                      ) => null,
                  chat: (_, __, messageText, senderNickname, isOwnMessage) =>
                      Tuple2(isOwnMessage ? 'human' : 'assistant', messageText),
                  chatWithAction: (_, __, messageText, senderNickname, isOwnMessage, requiresAction, actionData) =>
                      Tuple2(isOwnMessage ? 'human' : 'assistant', messageText),
                ),
              )
              .where((tuple) => tuple != null)
              .cast<Tuple2<String, String>>()
              .toList()
              .reversed
              .toList();
        }),
        
        // Location removed - using cached location from device status
        Future.value(ref.read(deviceStatusProvider).currentLocation),
        
        // ãƒ‡ãƒã‚¤ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®å–å¾—
        Future(() => ref.read(deviceStatusProvider)),
      ]);

      final chatHistory = results[0] as List<Tuple2<String, String>>;
      final currentLocation = results[1] as LocationModel?;
      final deviceStatusState = results[2] as DeviceStatusState;
      final isEmergencyMode = deviceStatusState.currentMode == 'emergency';
      
      // ãƒ‡ãƒãƒƒã‚°ï¼šææ¡ˆã‚«ãƒ¼ãƒ‰ã‹ã‚‰ã®ä½ç½®æƒ…å ±é€ä¿¡çŠ¶æ…‹ã‚’ãƒ­ã‚°å‡ºåŠ›
      if (kDebugMode) {
        print('[TimelineProvider] ğŸ“ === LOCATION DEBUG START ===');
        print('[TimelineProvider] ğŸ“ Message type: TIMELINE ACTION QUERY');
        print('[TimelineProvider] ğŸ“ Message: ${messageText.substring(0, messageText.length > 50 ? 50 : messageText.length)}...');
        if (currentLocation != null) {
          print('[TimelineProvider] âœ… Location available:');
          print('[TimelineProvider]   - Latitude: ${currentLocation.latitude}');
          print('[TimelineProvider]   - Longitude: ${currentLocation.longitude}');
          print('[TimelineProvider]   - Accuracy: ${currentLocation.accuracy}m');
        } else {
          print('[TimelineProvider] âŒ Location NOT available (timeout or error)');
        }
        print('[TimelineProvider] ğŸ“ === LOCATION DEBUG END ===');
      }

      // Add user message to timeline after building chat history
      state = state.copyWith(
        timelineItems: [...state.timelineItems, tempTimelineItem],
        currentChatInput: '',
        scrollBehavior: TimelineScrollBehavior.toBottom, // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¿½åŠ å¾Œã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
      );
      
      // debugPrint('[TimelineProvider] === SENDING CHAT MESSAGE ===');
      // debugPrint('[TimelineProvider] Current mode: ${deviceStatusState.currentMode}');
      // debugPrint('[TimelineProvider] Is emergency mode: $isEmergencyMode');
      // debugPrint('[TimelineProvider] Message: $messageText');

      // Update status
      state = state.copyWith(chatLoadingStatus: 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ä¸­...');

      // Get emergency contacts count
      final emergencyContactsCount = await _getEmergencyContactsCount();
      
      final apiResponse = await _apiService.sendChatMessage(
        message: messageText,
        deviceId: deviceId,
        sessionId: DateTime.now().millisecondsSinceEpoch.toString(),
        language: language,
        chatHistory: chatHistory,
        currentLocation: currentLocation,
        isDisasterMode: isEmergencyMode,
        emergencyContactsCount: emergencyContactsCount,
        cancelToken: cancelToken,
      );

      // Update status
      state = state.copyWith(chatLoadingStatus: 'AIãŒå›ç­”ã‚’ç”Ÿæˆä¸­...');

      // å‹å®‰å…¨ãªAPIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å›ç­”ã‚’å–å¾—
      final responseText = apiResponse.responseText;
      final generatedCards = apiResponse.generatedCardsForFrontend;
      final requiresAction = apiResponse.requiresAction;
      final actionData = apiResponse.actionData;
      
      // ğŸ” SMS ãƒ•ã‚©ãƒ¼ãƒ é–¢é€£ã®ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
      debugPrint('[TimelineProvider] requiresAction: $requiresAction');
      debugPrint('[TimelineProvider] actionData: ${actionData != null ? 'Present' : 'null'}');
      if (requiresAction != null) {
        debugPrint('[TimelineProvider] Action required: $requiresAction');
      }

      if (responseText != null && responseText.isNotEmpty) {
        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‹•ä½œãŒtoBottomã®å ´åˆã¯æ–°è¦IDã€ãã‚Œä»¥å¤–ã¯targetResponseIdã‚’ä½¿ç”¨
        final agentMessageId = (state.scrollBehavior == TimelineScrollBehavior.toBottom) 
            ? DateTime.now().millisecondsSinceEpoch.toString()
            : (state.targetResponseId ?? DateTime.now().millisecondsSinceEpoch.toString());
        
        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒå¿…è¦ãªå ´åˆã¯ç‰¹åˆ¥ãªãƒãƒ£ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã‚’ä½œæˆ
        if (requiresAction != null && actionData != null) {
          // ChatWithActionItemã‚’ä½œæˆã—ã¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‡¦ç†
          final agentMessage = TimelineItemModel.chatWithAction(
            id: agentMessageId,
            timestamp: DateTime.now(),
            messageText: responseText,
            senderNickname: 'SafetyBee',
            isOwnMessage: false,
            requiresAction: requiresAction,
            actionData: actionData,
          );
          
          state = state.copyWith(
            timelineItems: [...state.timelineItems, agentMessage],
            isChatLoading: false,
            chatLoadingStatus: '',
          );
          
          // ãƒãƒ£ãƒƒãƒˆå®Œäº†ã‚’DeviceStatusProviderã«é€šçŸ¥
          ref.read(deviceStatusProvider.notifier).endChatSession();
          
          // æ°¸ç¶šåŒ–
          _saveTimeline();
          
          return; // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ä»˜ããƒãƒ£ãƒƒãƒˆã®å ´åˆã¯ã“ã“ã§å‡¦ç†çµ‚äº†
        }
        
        // é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        final agentMessage = TimelineItemModel.chat(
          id: agentMessageId,
          timestamp: DateTime.now(),
          messageText: responseText,
          senderNickname: 'SafetyBee',
          isOwnMessage: false,
        );


        // ã¾ãšç¾åœ¨ã®ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚³ãƒ”ãƒ¼
        List<TimelineItemModel> newTimelineItems = [...state.timelineItems];

        // ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯ã€ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—åˆ¥ã«å‡¦ç†
        if (generatedCards != null && generatedCards.isNotEmpty) {
      // debugPrint('[TimelineProvider] ğŸ—ºï¸ Processing generated cards...');
          for (final card in generatedCards) {
      // debugPrint('[TimelineProvider] Card: type=${card['type']}, card_type=${card['card_type']}, title=${card['title']}');
            // Debug location data
            final location = card['location'] as Map<String, dynamic>?;
            if (location != null) {
      // debugPrint('[TimelineProvider] ğŸ—ºï¸ Card location: lat=${location['latitude']}, lng=${location['longitude']}');
            } else {
      // debugPrint('[TimelineProvider] ğŸ—ºï¸ Card has no location data');
            }
          }
          
          // é¿é›£æ‰€é–¢é€£ã‚¿ã‚¤ãƒ—ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆä½ç½®æƒ…å ±ãŒã‚ã‚‹ã‚‚ã®ã®ã¿ï¼‰
          final shelterCards = generatedCards
              .where((card) {
                // é¿é›£æ‰€é–¢é€£ã®ã‚¿ã‚¤ãƒ—ã‚’ãƒã‚§ãƒƒã‚¯
                final isEvacuationType = 
                  card['type'] == 'shelter_status_update' ||
                  card['card_type'] == 'evacuation_info' ||
                  card['type'] == 'shelter_location' ||
                  card['type'] == 'shelter_info' ||
                  card['card_type'] == 'evacuation_shelter' ||
                  card['card_type'] == 'shelter' ||
                  card['type'] == 'evacuation_shelter' ||
                  card['type'] == 'shelter';
                
                if (!isEvacuationType) return false;
                
                // ä½ç½®æƒ…å ±ï¼ˆç·¯åº¦çµŒåº¦ï¼‰ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                final location = card['location'] as Map<String, dynamic>?;
                final data = card['data'] as Map<String, dynamic>?;
                
                final hasLatitude = location?['latitude'] != null || 
                                   data?['latitude'] != null ||
                                   card['shelter_latitude'] != null;
                final hasLongitude = location?['longitude'] != null || 
                                     data?['longitude'] != null ||
                                     card['shelter_longitude'] != null;
                
                return hasLatitude && hasLongitude;
              })
              .toList();
              
          // ä¸€èˆ¬çš„ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆé¿é›£æ‰€é–¢é€£ä»¥å¤–ï¼‰
          final actionCards = generatedCards
              .where((card) {
                final cardType = card['type'] as String?;
                final cardCardType = card['card_type'] as String?;
                
                // é¿é›£æ‰€é–¢é€£ã¯é™¤å¤–ï¼ˆä¸Šã§åˆ¥å‡¦ç†ï¼‰
                final isEvacuationType = 
                  cardType == 'shelter_status_update' ||
                  cardCardType == 'evacuation_info' ||
                  cardType == 'shelter_location' ||
                  cardType == 'shelter_info' ||
                  cardCardType == 'evacuation_shelter' ||
                  cardCardType == 'shelter' ||
                  cardType == 'evacuation_shelter' ||
                  cardType == 'shelter';
                  
                if (isEvacuationType) return false;
                
                // ä¸€èˆ¬çš„ãªã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚’å«ã‚ã‚‹
                return cardType == 'action' ||
                       cardType == 'preparedness_tip' ||
                       cardType == 'guide_info' ||  // ã‚¬ã‚¤ãƒ‰æƒ…å ±ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ 
                       cardType == 'disaster_info' ||  // ç½å®³æƒ…å ±ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ 
                       cardCardType == 'hazard_map_info' ||
                       cardCardType == 'hazard_map_viewer' ||
                       cardCardType == 'guide_info' ||  // card_typeã¨ã—ã¦ã®guide_infoã‚‚è¿½åŠ 
                       card.containsKey('action_query'); // action_queryãŒã‚ã‚‹ã‚‚ã®ã¯å…¨ã¦å«ã‚ã‚‹
              })
              .toList();

          if (shelterCards.isNotEmpty) {

            // ç¾åœ¨ã®ä½ç½®æƒ…å ±ã‚’å–å¾—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
            final currentLocation = ref.read(deviceStatusProvider).currentLocation;
            LatLng? userLocation;
            if (currentLocation != null) {
              userLocation = LatLng(
                currentLocation.latitude,
                currentLocation.longitude,
              );
            }

            // é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ã‚’äº‹å‰å‡¦ç†ã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
            final processedShelters = _preprocessShelterData(shelterCards);
            final shelterData = {
              'shelters': shelterCards,
              'processedShelters': processedShelters, // äº‹å‰å‡¦ç†æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
              'userLocation': userLocation != null
                  ? {
                      'latitude': userLocation.latitude,
                      'longitude': userLocation.longitude,
                    }
                  : null,
            };
            
            // ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒã‚·ãƒ¥ãƒ™ãƒ¼ã‚¹ã§ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªIDã‚’ç”Ÿæˆ
            final shelterDataHash = _generateShelterDataHash(shelterData);
            final shelterMapId = 'shelter_map_$shelterDataHash';
            
            // æ—¢å­˜ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ãƒã‚§ãƒƒã‚¯
            final updatedCache = {...state.shelterDataCache};
            if (!updatedCache.containsKey(shelterMapId)) {
              // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã®ã¿ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«è¿½åŠ 
              updatedCache[shelterMapId] = shelterData;
            }
            
            // çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä¿å­˜
            state = state.copyWith(shelterDataCache: updatedCache);
            
            // ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸IDã¨é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿IDã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä¿å­˜
            final updatedMapping = {...state.chatIdToShelterDataId};
            updatedMapping[agentMessageId] = shelterMapId;
            state = state.copyWith(chatIdToShelterDataId: updatedMapping);
            
            // é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ã‚’æ°¸ç¶šåŒ–
            _saveTimeline();
          }

          // ä¸€èˆ¬çš„ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã®å‡¦ç†
          if (actionCards.isNotEmpty) {
            for (final actionCard in actionCards) {
              final cardType = actionCard['type'] as String? ?? actionCard['card_type'] as String? ?? 'unknown';
              final cardId = actionCard['card_id'] as String? ?? 'action_${DateTime.now().millisecondsSinceEpoch}';
              
              // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—åˆ¥ã®å‡¦ç†
              if (cardType == 'action') {
                // clarification_handlerã‹ã‚‰ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰
                final suggestionCard = TimelineItemModel.suggestion(
                  id: cardId,
                  suggestionType: 'action_selection',
                  content: actionCard['text'] as String? ?? 'ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’é¸æŠ',
                  actionData: {
                    'action_type': actionCard['action'],
                    'original_card_data': actionCard,
                  },
                  actionQuery: _generateActionQuery(actionCard['action'] as String?),
                  actionDisplayText: actionCard['text'] as String? ?? 'é¸æŠ',
                  timestamp: DateTime.now(),
                );
                newTimelineItems.add(suggestionCard);
                
              } else if (cardType == 'preparedness_tip') {
                // æº–å‚™ãƒ»ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚«ãƒ¼ãƒ‰
                final suggestionCard = TimelineItemModel.suggestion(
                  id: cardId,
                  suggestionType: 'preparedness_tip',
                  content: actionCard['title'] as String? ?? actionCard['content'] as String? ?? 'æº–å‚™ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ',
                  actionData: {
                    'tip_data': actionCard,
                    'checklist_items': actionCard['checklist_items'],
                  },
                  actionQuery: actionCard['action_query'] as String?,
                  actionDisplayText: actionCard['action_display_text'] as String? ?? 'ãƒã‚§ãƒƒã‚¯',
                  timestamp: DateTime.now(),
                );
                newTimelineItems.add(suggestionCard);
                
              } else if (actionCard['card_type'] == 'hazard_map_info' || actionCard['card_type'] == 'hazard_map_viewer') {
                // ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã‚«ãƒ¼ãƒ‰
                final actionButtons = actionCard['action_buttons'] as List<dynamic>?;
                
                if (actionButtons != null && actionButtons.isNotEmpty) {
                  // æ–°ã—ã„å½¢å¼: action_buttonsé…åˆ—ã‹ã‚‰è¤‡æ•°ã®ãƒœã‚¿ãƒ³ã‚’ç”Ÿæˆ
                  for (int i = 0; i < actionButtons.length; i++) {
                    final button = actionButtons[i] as Map<String, dynamic>;
                    final hazardMapId = '${cardId}_button_$i';
                    
                    final hazardMapCard = TimelineItemModel.suggestion(
                      id: hazardMapId,
                      suggestionType: 'hazard_map_url',
                      content: actionCard['title'] ?? 'ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—',
                      actionData: {
                        'action': 'open_hazard_map',
                        'url': button['url'],
                        'title': button['label'] ?? actionCard['title'],
                        'description': actionCard['description'],
                      },
                      actionQuery: null,
                      actionDisplayText: button['label'] ?? 'ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã‚’é–‹ã',
                      timestamp: DateTime.now(),
                    );
                    newTimelineItems.add(hazardMapCard);
                  }
                } else {
                  // æ—§å½¢å¼: å˜ä¸€ã®action_url
                  final hazardMapCard = TimelineItemModel.suggestion(
                    id: cardId,
                    suggestionType: 'hazard_map_url',
                    content: actionCard['title'] ?? 'ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—',
                    actionData: {
                      'action': 'open_hazard_map',
                      'url': actionCard['action_url'],
                      'title': actionCard['title'],
                      'description': actionCard['description'],
                    },
                    actionQuery: null,
                    actionDisplayText: 'ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã‚’é–‹ã',
                    timestamp: DateTime.now(),
                  );
                  newTimelineItems.add(hazardMapCard);
                }
              } else {
                // ãã®ä»–ã®ä¸€èˆ¬çš„ãªã‚«ãƒ¼ãƒ‰ï¼ˆaction_queryãŒã‚ã‚‹ã‚‚ã®ï¼‰
                final suggestionCard = TimelineItemModel.suggestion(
                  id: cardId,
                  suggestionType: cardType,
                  content: actionCard['title'] as String? ?? actionCard['content'] as String? ?? 'ã‚«ãƒ¼ãƒ‰',
                  actionData: {
                    'card_data': actionCard,
                  },
                  actionQuery: actionCard['action_query'] as String?,
                  actionDisplayText: actionCard['action_display_text'] as String? ?? 'ã‚¢ã‚¯ã‚·ãƒ§ãƒ³',
                  timestamp: DateTime.now(),
                );
                newTimelineItems.add(suggestionCard);
              }
            }
          }
        }

        // æœ€å¾Œã«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
        newTimelineItems.add(agentMessage);

        state = state.copyWith(
          timelineItems: newTimelineItems,
          isChatLoading: false,
          chatLoadingStatus: '',
          scrollBehavior: TimelineScrollBehavior.toBottom, // AIè¿”ç­”å¾Œã‚‚æœ€ä¸‹éƒ¨ã¸ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
        );

        // ãƒãƒ£ãƒƒãƒˆå®Œäº†ã‚’DeviceStatusProviderã«é€šçŸ¥
        if (!_isDisposed) {
          ref.read(deviceStatusProvider.notifier).endChatSession();
        }

      } else {
        if (!_isDisposed) {
          state = state.copyWith(
            isChatLoading: false,
            chatLoadingStatus: '',
          );
        }
        
        // ãƒãƒ£ãƒƒãƒˆå®Œäº†ã‚’DeviceStatusProviderã«é€šçŸ¥ï¼ˆãƒ¬ã‚¹ãƒãƒ³ã‚¹ãªã—æ™‚ï¼‰
        if (!_isDisposed) {
          ref.read(deviceStatusProvider.notifier).endChatSession();
        }
      }
    } catch (e, stackTrace) {
      // debugPrint('[TimelineProvider] Failed to send chat message: $e');
      // debugPrint('[TimelineProvider] Stack trace: $stackTrace');
      
      if (_isDisposed) {
      // debugPrint('Provider disposed during chat message, skipping state update');
        return;
      }
      
      // Check if error is due to cancellation
      String errorMessage;
      if (e is DioException && e.type == DioExceptionType.cancel) {
        errorMessage = "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ";
      } else {
        errorMessage = "Failed to send message: ${e.toString()}";
      }
      
      state = state.copyWith(
        errorMessage: errorMessage,
        timelineItems: state.timelineItems
            .where((item) => item != tempTimelineItem)
            .toList(),
        isChatLoading: false,
        chatLoadingStatus: '',
        chatCancelToken: null,
      );
      
      // ãƒãƒ£ãƒƒãƒˆå®Œäº†ã‚’DeviceStatusProviderã«é€šçŸ¥ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ï¼‰
      if (!_isDisposed) {
        ref.read(deviceStatusProvider.notifier).endChatSession();
      }
    }
  }

  void setImportantAlert(AlertModel? alert) {
    state = state.copyWith(importantAlert: alert);
  }

  /// FCMã‹ã‚‰å—ä¿¡ã—ãŸç½å®³ã‚¢ãƒ©ãƒ¼ãƒˆã‚’å‡¦ç†
  /// çµ±ä¸€ã•ã‚ŒãŸã‚¢ãƒ©ãƒ¼ãƒˆå‡¦ç†ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆFCMã‹ã‚‰ã®ã¿å‘¼ã³å‡ºã•ã‚Œã‚‹ï¼‰
  void processEmergencyAlert(Map<String, dynamic> alertData) {
      // debugPrint('[TimelineProvider] Processing FCM emergency alert');

    // 1. ã‚¢ãƒ©ãƒ¼ãƒˆIDç”Ÿæˆï¼ˆé‡è¤‡é˜²æ­¢ã®ãŸã‚ï¼‰
    final alertId = alertData['alert_id'] ?? alertData['id'] ?? '';
    final alertTimestamp = DateTime.tryParse(alertData['timestamp'] ?? '') ?? DateTime.now();
    final uniqueAlertId = alertId.isNotEmpty 
        ? alertId 
        : 'alert_${alertTimestamp.millisecondsSinceEpoch}';

    // 2. åŒ…æ‹¬çš„é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆID + ã‚¿ã‚¤ãƒ— + 24æ™‚é–“ä»¥å†…ï¼‰
    final isDuplicate = _isAlertDuplicate(uniqueAlertId, alertTimestamp);
    if (isDuplicate) {
      // debugPrint('[TimelineProvider] Duplicate alert detected, skipping');
      return;
    }

    // 3. ã‚¢ãƒ©ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿æŠ½å‡ºã¨ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚º
    final alertType = alertData['alert_type'] ?? alertData['disaster_type'] ?? 'emergency';
    final userLanguage = ref.read(settingsProvider).currentUserSettings?.languageCode ?? 'ja';
    
    // ã‚¿ã‚¤ãƒˆãƒ«ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚º
    final localizedData = _getLocalizedAlertContent(alertType, userLanguage);
    final title = localizedData['title'] ?? alertData['title'] ?? 'ç·Šæ€¥ã‚¢ãƒ©ãƒ¼ãƒˆ';
    final message = localizedData['message'] ?? alertData['body'] ?? alertData['description'] ?? '';
    
    final severity = _parseAlertSeverity(
      alertData['disaster_level'] ?? alertData['severity'] ?? 'emergency',
    );

    // 4. AlertModelä½œæˆ
    final alert = AlertModel(
      id: uniqueAlertId,
      title: title,
      message: message,
      severity: severity,
      timestamp: alertTimestamp,
      source: alertData['disaster_type'] ?? alertData['alert_type'] ?? 'emergency',
      area: alertData['area'] ?? 'å¯¾è±¡åœ°åŸŸ',
    );

    // 5. ImportantAlertBannerè¨­å®šï¼ˆæœ€æ–°ã‚¢ãƒ©ãƒ¼ãƒˆã®ã¿ï¼‰
    setImportantAlert(alert);

    // 6. TimelineItemè¿½åŠ 
    final alertItem = TimelineItemModel.alert(
      id: 'timeline_$uniqueAlertId',
      timestamp: alert.timestamp,
      severity: alert.severity.name,
      title: alert.title,
      message: alert.message,
    );

    state = state.copyWith(
      timelineItems: [...state.timelineItems, alertItem],
      scrollBehavior: TimelineScrollBehavior.toAlert,
      targetAlertId: alertItem.id,
    );
    
    // 7. ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æ°¸ç¶šåŒ–ï¼ˆç·Šæ€¥ã‚¢ãƒ©ãƒ¼ãƒˆã¯å³åº§ã«ä¿å­˜ï¼‰
    _saveTimelineImmediate();

    // 8. ç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰ææ¡ˆã®å–å¾—ã¨è‡ªå‹•ç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
    if (severity == AlertSeverity.emergency || severity == AlertSeverity.critical) {
      // ç·Šæ€¥ã‚¢ãƒ©ãƒ¼ãƒˆå—ä¿¡æ™‚ã«è‡ªå‹•çš„ã«ç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
      if (ref.exists(deviceStatusProvider)) {
        ref.read(deviceStatusProvider.notifier).setEmergencyMode(true);
        // debugPrint('[TimelineProvider] Emergency alert received - switching to emergency mode');
      }
      
      // ç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰ææ¡ˆã¯DeviceStatusProviderã®ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆã§è‡ªå‹•çš„ã«å–å¾—ã•ã‚Œã‚‹
      // debugPrint('[TimelineProvider] Emergency alert processed - suggestions will be fetched via heartbeat');
    }
  }

  /// é‡è¤‡ã‚¢ãƒ©ãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯ï¼ˆ24æ™‚é–“ä»¥å†…ã®åŒä¸€ã‚¢ãƒ©ãƒ¼ãƒˆï¼‰
  bool _isAlertDuplicate(String alertId, DateTime timestamp) {
    const duplicateWindow = Duration(hours: 24);
    final cutoffTime = timestamp.subtract(duplicateWindow);
    
    return state.timelineItems.any((item) =>
        item.when(
          alert: (id, itemTimestamp, __, ___, ____) {
            // IDãŒåŒã˜ã€ã¾ãŸã¯24æ™‚é–“ä»¥å†…ã®åŒä¸€ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
            return (id.contains(alertId) && alertId.isNotEmpty) ||
                   (itemTimestamp.isAfter(cutoffTime) && 
                    itemTimestamp.difference(timestamp).abs() < const Duration(seconds: 1));
          },
          suggestion: (_, __, ___, ____, _____, ______, _______) => false,
          chat: (_, __, ___, ____, _____) => false,
          chatWithAction: (_, __, ___, ____, _____, ______, _______) => false,
        ));
  }

  /// å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ—§ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ–°ãƒ¡ã‚½ãƒƒãƒ‰ã«è»¢é€
  void handleDisasterAlert(Map<String, dynamic> alertData) {
      // debugPrint('[TimelineProvider] âš ï¸ Legacy handleDisasterAlert called, forwarding to processEmergencyAlert');
    processEmergencyAlert(alertData);
  }

  /// æ–‡å­—åˆ—ã‚’AlertSeverityã«å¤‰æ›
  AlertSeverity _parseAlertSeverity(String severityStr) {
    switch (severityStr.toLowerCase()) {
      case 'info':
        return AlertSeverity.info;
      case 'warning':
        return AlertSeverity.warning;
      case 'danger':
        return AlertSeverity.danger;
      case 'emergency':
        return AlertSeverity.emergency;
      case 'critical':
        return AlertSeverity.critical;
      default:
        return AlertSeverity.emergency;
    }
  }

  void clearErrorMessage() {
    state = state.copyWith(errorMessage: null);
  }

  void dismissImportantAlert() {
    state = state.copyWith(importantAlert: null);
  }

  /// Clear normal mode suggestions when switching to emergency mode
  void clearNormalModeSuggestions() {
    
    // Define emergency suggestion types that should be kept
    const emergencySuggestionTypes = {
      'immediate_safety_action',
      'evacuation_prompt',
      'emergency_guidance',
      'disaster_info',
      'evacuation_instruction',
      'publicSafetyInfoForCurrentLocation',
      'safety_confirmation_sms_proposal',
      'hazard_map_url',
      'shelter_info',
      'shelter_status_update',
    };
    
    // Filter out normal mode suggestions
    final filteredItems = state.timelineItems.where((item) {
      return item.when(
        alert: (_, __, ___, ____, _____) => true, // Keep all alerts
        chat: (_, __, ___, ____, _____) => true, // Keep all chats
        chatWithAction: (_, __, ___, ____, _____, ______, _______) => true, // Keep all chat with actions
        suggestion: (_, __, suggestionType, ____, actionData, _____, ______) {
          // Keep only emergency-related suggestions
          return emergencySuggestionTypes.contains(suggestionType);
        },
      );
    }).toList();
    
    
    state = state.copyWith(timelineItems: filteredItems);
    _saveTimelineImmediate();
  }

  /// Clear emergency mode suggestions when switching back to normal mode
  void clearEmergencyModeSuggestions() {
    
    // Define emergency suggestion types that should be removed
    const emergencySuggestionTypes = {
      'immediate_safety_action',
      'evacuation_prompt',
      'emergency_guidance',
      'disaster_info',
      'evacuation_instruction',
      'publicSafetyInfoForCurrentLocation',
      'safety_confirmation_sms_proposal',
      'hazard_map_url',
      'shelter_info',
      'shelter_status_update',
    };
    
    // Filter out emergency mode suggestions
    final filteredItems = state.timelineItems.where((item) {
      return item.when(
        alert: (_, __, severity, ____, _____) {
          // Remove emergency alerts
          return severity != 'critical' && severity != 'warning';
        },
        chat: (_, __, ___, ____, _____) => true, // Keep all chats
        chatWithAction: (_, __, ___, ____, _____, ______, _______) => true, // Keep all chat with actions
        suggestion: (_, __, suggestionType, ____, actionData, _____, ______) {
          // Remove emergency-related suggestions
          return !emergencySuggestionTypes.contains(suggestionType);
        },
      );
    }).toList();
    
    
    state = state.copyWith(timelineItems: filteredItems);
    _saveTimelineImmediate();
  }


  /// ç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰æ¤œå‡ºæ™‚ã®SSEè‡ªå‹•é–‹å§‹ï¼ˆç„¡åŠ¹åŒ–æ¸ˆã¿ï¼‰
  void _checkEmergencyModeForSSE() {
    // ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆçµ±åˆã«ã‚ˆã‚Šç„¡åŠ¹åŒ–
  }

  /// ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆAPIã‹ã‚‰å—ä¿¡ã—ãŸãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ææ¡ˆã®å‡¦ç†
  void addProactiveSuggestions(List<TimelineItemModel> suggestions) async {
    // Turn off loading state after receiving first response
    if (state.isLoading) {
      state = state.copyWith(isLoading: false);
    }
    
    if (suggestions.isEmpty) {
      // debugPrint('[TimelineProvider] âš ï¸ No suggestions to add - returning early');
      return;
    }
    
      // debugPrint('[TimelineProvider] ğŸ“¥ Received ${suggestions.length} suggestions - processing for duplicates');
    
    // å—ä¿¡ã—ãŸææ¡ˆã‚’å‚è€ƒæƒ…å ±ã¨ã—ã¦ãƒ­ã‚°å‡ºåŠ›
    for (int i = 0; i < suggestions.length; i++) {
      final suggestion = suggestions[i];
      suggestion.when(
        alert: (id, timestamp, severity, title, message) {
      // debugPrint('[TimelineProvider]   [$i] ALERT: $id - $title');
        },
        suggestion: (id, suggestionType, timestamp, content, actionData, actionQuery, actionDisplayText) {
      // debugPrint('[TimelineProvider]   [$i] SUGGESTION: $id ($suggestionType) - ${content.substring(0, content.length.clamp(0, 50))}...');
        },
        chat: (id, timestamp, messageText, senderNickname, isOwnMessage) {
      // debugPrint('[TimelineProvider]   [$i] CHAT: $id - ${messageText.substring(0, messageText.length.clamp(0, 50))}...');
        },
        chatWithAction: (id, timestamp, messageText, senderNickname, isOwnMessage, requiresAction, actionData) {
      // debugPrint('[TimelineProvider]   [$i] CHAT WITH ACTION: $id - ${messageText.substring(0, messageText.length.clamp(0, 50))}...');
        },
      );
    }
    
    // æ—¢å­˜ã®ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‹ã‚‰é‡è¤‡ã™ã‚‹ææ¡ˆã‚’é™¤å¤–ï¼ˆã‚¿ã‚¤ãƒ—ã¨å†…å®¹ã§åˆ¤å®šï¼‰
    final existingSuggestions = state.timelineItems
        .where((item) => item.type == TimelineItemType.suggestion)
        .map((item) => item.when(
              alert: (_, __, ___, ____, _____) => null,
              chat: (_, __, ___, ____, _____) => null,
              chatWithAction: (_, __, ___, ____, _____, ______, _______) => null,
              suggestion: (id, suggestionType, timestamp, content, _____, ______, _______) => {
                'id': id,
                'type': suggestionType,
                'content': content,
                'timestamp': timestamp.toIso8601String(),
              },
            ))
        .where((item) => item != null)
        .cast<Map<String, String>>()
        .toList();

    // æ—¢å­˜ã®ã‚¢ãƒ©ãƒ¼ãƒˆIDã‚’å–å¾—ï¼ˆç½å®³æƒ…å ±ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨ï¼‰
    final existingAlertIds = state.timelineItems
        .where((item) => item.type == TimelineItemType.alert)
        .map((item) => item.when(
              alert: (id, __, ___, ____, _____) => id,
              chat: (_, __, ___, ____, _____) => '',
              chatWithAction: (_, __, ___, ____, _____, ______, _______) => '',
              suggestion: (_, __, ___, ____, _____, ______, _______) => '',
            ))
        .where((id) => id.isNotEmpty)
        .toSet();

      // debugPrint('[TimelineProvider] ğŸ” Existing content check:');
      // debugPrint('[TimelineProvider]   - Existing alert IDs: $existingAlertIds');

    
    // ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’å–å¾—ï¼ˆç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰åˆ¤å®šç”¨ï¼‰
    final deviceStatus = ref.read(deviceStatusProvider);
    final isCurrentlyEmergencyMode = deviceStatus.currentMode == 'emergency';
    
    // é‡è¤‡ã—ã¦ã„ãªã„ææ¡ˆã®ã¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆææ¡ˆã‚¿ã‚¤ãƒ—ã¨ç½å®³æƒ…å ±é‡è¤‡ã§åˆ¤å®šï¼‰
    final newSuggestions = suggestions.where((suggestion) {
      return suggestion.when(
        alert: (_, __, ___, ____, _____) => true,
        chat: (_, __, ___, ____, _____) => true,
        chatWithAction: (_, __, ___, ____, _____, ______, _______) => true,
        suggestion: (_, suggestionType, __, content, actionData, _____, ______) {
          // å†…å®¹ãƒ™ãƒ¼ã‚¹ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
          final isDuplicate = _isDuplicateSuggestion(suggestionType, content, existingSuggestions);
          if (isDuplicate) {
      // debugPrint('[TimelineProvider] ğŸš« Duplicate suggestion filtered: $suggestionType');
          } else {
      // debugPrint('[TimelineProvider] âœ… New suggestion accepted: $suggestionType');
          }
          return !isDuplicate;
        },
      );
    }).toList();

      // debugPrint('[TimelineProvider] ğŸ” Duplicate check results:');
      // debugPrint('[TimelineProvider]   - Existing suggestions in timeline: ${existingSuggestions.length}');
    final existingTypes = existingSuggestions.map((s) => s['type']).toSet();
      // debugPrint('[TimelineProvider]   - Existing suggestion types: $existingTypes');
      // debugPrint('[TimelineProvider]   - New suggestions received: ${suggestions.length}');
      // debugPrint('[TimelineProvider]   - After duplicate filtering: ${newSuggestions.length}');
      // debugPrint('[TimelineProvider]   - Emergency mode: $isCurrentlyEmergencyMode');
    
    if (newSuggestions.isNotEmpty) {
      // debugPrint('[TimelineProvider] ğŸ”„ Filtered out ${suggestions.length - newSuggestions.length} duplicate suggestions');
      
      // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã«æ–°ã—ã„ææ¡ˆã‚’è¿½åŠ ï¼ˆä¸‹ã«è¿½åŠ ï¼šä¸ŠãŒå¤ã„ã€ä¸‹ãŒæ–°ã—ã„ï¼‰
      state = state.copyWith(
        timelineItems: [...state.timelineItems, ...newSuggestions],
      );
      
      // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚’ä¿å­˜
      _saveTimeline();
      
      // ç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰æ™‚ã®SSEãƒã‚§ãƒƒã‚¯
      _checkEmergencyModeForSSE();
      
      // debugPrint('[TimelineProvider] âœ… Added ${newSuggestions.length} new suggestions to timeline');
    } else {
      // debugPrint('[TimelineProvider] âš ï¸ All suggestions were duplicates - not adding any');
    }
  }

  /// SSEã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‹ã‚‰å—ä¿¡ã—ãŸææ¡ˆã‚’ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã«è¿½åŠ 
  void addStreamingSuggestion(TimelineItemModel suggestion) {
    // å˜ä¸€ã®ææ¡ˆã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦å‡¦ç†
    addProactiveSuggestions([suggestion]);
  }

  /// ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ææ¡ˆã‚’ã‚¿ãƒƒãƒ—ã—ãŸéš›ã«ã€actionQueryã‚’é€ä¿¡ã—ã¦ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å›ç­”ã‚’å–å¾—
  Future<void> sendSuggestionQuery(TimelineItemModel suggestion) async {
    await suggestion.when(
      alert: (_, __, ___, ____, _____) async {
        // ã‚¢ãƒ©ãƒ¼ãƒˆã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
      },
      suggestion:
          (
            _,
            __,
            ___,
            content,
            actionData,
            actionQuery,
            actionDisplayText,
          ) async {
            final query = actionQuery ?? "ã“ã®ææ¡ˆã«ã¤ã„ã¦æ•™ãˆã¦ãã ã•ã„";
            final displayText = actionDisplayText ?? content;
            await sendActionQuery(
              query,
              displayText,
            );
          },
      chat: (_, __, ___, ____, _____) async {
        // ãƒãƒ£ãƒƒãƒˆã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
      },
      chatWithAction: (_, __, ___, ____, _____, ______, _______) async {
        // ãƒãƒ£ãƒƒãƒˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
      },
    );
  }

  /// ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ææ¡ˆã‚’ã‚¿ãƒƒãƒ—ã—ãŸéš›ã«ã€actionQueryã‚’é€ä¿¡ã—ã¦ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å›ç­”ã‚’å–å¾—
  Future<void> sendActionQuery(
    String actionQuery,
    String displayText,
  ) async {
    if (actionQuery.isEmpty) return;

    // ãƒãƒ£ãƒƒãƒˆé–‹å§‹ã‚’DeviceStatusProviderã«é€šçŸ¥
    ref.read(deviceStatusProvider.notifier).startChatSession();

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¯ã‚¨ãƒªã‚’ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã«è¿½åŠ ï¼ˆactionQueryã§ã¯ãªãdisplayTextã‚’è¡¨ç¤ºï¼‰
    final userMessageId = DateTime.now().millisecondsSinceEpoch.toString();
    final userMessage = TimelineItemModel.chat(
      id: userMessageId,
      timestamp: DateTime.now(),
      messageText: displayText,
      senderNickname: 'You',
      isOwnMessage: true,
    );

    // Response IDã‚’ç”Ÿæˆï¼ˆã“ã®å¾Œè¿½åŠ ã•ã‚Œã‚‹å›ç­”ã®IDï¼‰
    final responseId = 'response_${DateTime.now().millisecondsSinceEpoch}';
    
    state = state.copyWith(
      timelineItems: [...state.timelineItems, userMessage],
      isChatLoading: true,
      scrollBehavior: TimelineScrollBehavior.toResponse,
      targetResponseId: responseId,
    );

    try {
      // ä¸¦åˆ—å‡¦ç†ã§å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      final results = await Future.wait([
        // ãƒ‡ãƒã‚¤ã‚¹IDå–å¾—
        ref.read(deviceStatusProvider.notifier).getDeviceId(),
        
        // Location removed - using cached location from device status
        Future.value(ref.read(deviceStatusProvider).currentLocation),
        
        // ãƒãƒ£ãƒƒãƒˆå±¥æ­´æ§‹ç¯‰ï¼ˆåŒæœŸå‡¦ç†ãªã®ã§Future.valueã§ãƒ©ãƒƒãƒ—ï¼‰
        Future.value(state.timelineItems
            .where((item) => item.type == TimelineItemType.chat)
            .take(10)
            .map((item) => item.when(
                  alert: (_, __, ___, ____, _____) => null,
                  suggestion: (_, __, ___, ____, _____, ______, _______) => null,
                  chat: (_, __, messageText, senderNickname, isOwnMessage) =>
                      Tuple2(isOwnMessage ? 'human' : 'assistant', messageText),
                  chatWithAction: (_, __, messageText, senderNickname, isOwnMessage, requiresAction, actionData) =>
                      Tuple2(isOwnMessage ? 'human' : 'assistant', messageText),
                ))
            .where((tuple) => tuple != null)
            .cast<Tuple2<String, String>>()
            .toList()
            .reversed
            .toList()),
      ]);

      final deviceId = results[0] as String;
      final currentLocation = results[1] as LocationModel?;
      final chatHistory = results[2] as List<Tuple2<String, String>>;

      // è¨€èªã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ï¼ˆLocalStorageã‹ã‚‰ç›´æ¥èª­ã¿è¾¼ã¿ - sendChatMessageã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
      String language = 'ja'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
      try {
        final localStorage = ref.read(localStorageServiceProvider);
        final directSettings = await localStorage.loadUserSettings();
        if (directSettings != null && directSettings.languageCode.isNotEmpty) {
          language = directSettings.languageCode;
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šSettingsProviderã‚’ç¢ºèª
          final settingsState = ref.read(settingsProvider);
          if (!settingsState.isLoading && settingsState.currentUserSettings != null) {
            language = settingsState.currentUserSettings!.languageCode;
          }
        }
      } catch (e) {
      // debugPrint('[TimelineProvider] Language retrieval failed: $e');
      }
      
      // debugPrint('[TimelineProvider] Using language: $language');
      
      // ãƒ‡ãƒã‚¤ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèª
      final deviceStatusState = ref.read(deviceStatusProvider);
      final isEmergencyMode = deviceStatusState.currentMode == 'emergency';
      
      // debugPrint('[TimelineProvider] === SENDING ACTION QUERY ===');
      // debugPrint('[TimelineProvider] Current mode: ${deviceStatusState.currentMode}');
      // debugPrint('[TimelineProvider] Is emergency mode: $isEmergencyMode');
      // debugPrint('[TimelineProvider] Action query: $actionQuery');

      final apiResponse = await _apiService.sendChatMessage(
        message: actionQuery,
        deviceId: deviceId,
        sessionId: DateTime.now().millisecondsSinceEpoch.toString(),
        language: language,
        chatHistory: chatHistory,
        currentLocation: currentLocation,
        isDisasterMode: isEmergencyMode,
      );

      // debugPrint('Action query sent: $actionQuery');
      // debugPrint('Display text: $displayText');
      // debugPrint('API response: $apiResponse');

      // å‹å®‰å…¨ãªAPIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å›ç­”ã‚’å–å¾—
      final responseText = apiResponse.responseText;
      final generatedCards = apiResponse.generatedCardsForFrontend;

      // debugPrint('[TimelineProvider] Processing action query API response...');
      // debugPrint('[TimelineProvider] Response text: $responseText');
      // debugPrint('[TimelineProvider] Generated cards: $generatedCards');

      if (responseText != null && responseText.isNotEmpty) {
        // responseIdã‚’ç›´æ¥ä½¿ç”¨ï¼ˆsendActionQueryé–‹å§‹æ™‚ã«ç”Ÿæˆã—ãŸIDï¼‰
        final agentMessageId = responseId;
      // debugPrint('[TimelineProvider] Creating agent message with ID: $agentMessageId');
      // debugPrint('[TimelineProvider] Using responseId from start of sendActionQuery: $responseId');
      // debugPrint('[TimelineProvider] Current targetResponseId in state: ${state.targetResponseId}');
      // debugPrint('[TimelineProvider] Current scrollBehavior: ${state.scrollBehavior}');
        
        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ãã®ã¾ã¾ä½¿ç”¨
        String finalMessageText = responseText;

        // ã¾ãšç¾åœ¨ã®ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚³ãƒ”ãƒ¼
        List<TimelineItemModel> updatedItems = [...state.timelineItems];

        // Generated Cards ã®å‡¦ç†
        if (generatedCards != null && generatedCards.isNotEmpty) {
          // é¿é›£æ‰€é–¢é€£ã‚¿ã‚¤ãƒ—ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆä½ç½®æƒ…å ±ãŒã‚ã‚‹ã‚‚ã®ã®ã¿ï¼‰
          final shelterCards = generatedCards
              .where((card) {
                // é¿é›£æ‰€é–¢é€£ã®ã‚¿ã‚¤ãƒ—ã‚’ãƒã‚§ãƒƒã‚¯
                final isEvacuationType = 
                  card['type'] == 'shelter_status_update' ||
                  card['card_type'] == 'evacuation_info' ||
                  card['type'] == 'shelter_location' ||
                  card['type'] == 'shelter_info' ||
                  card['card_type'] == 'evacuation_shelter' ||
                  card['card_type'] == 'shelter' ||
                  card['type'] == 'evacuation_shelter' ||
                  card['type'] == 'shelter';
                
                if (!isEvacuationType) return false;
                
                // ä½ç½®æƒ…å ±ï¼ˆç·¯åº¦çµŒåº¦ï¼‰ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                final location = card['location'] as Map<String, dynamic>?;
                final data = card['data'] as Map<String, dynamic>?;
                
                final hasLatitude = location?['latitude'] != null || 
                                   data?['latitude'] != null ||
                                   card['shelter_latitude'] != null;
                final hasLongitude = location?['longitude'] != null || 
                                     data?['longitude'] != null ||
                                     card['shelter_longitude'] != null;
                
                return hasLatitude && hasLongitude;
              })
              .toList();
          
          // é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯ã€ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«åŸ‹ã‚è¾¼ã‚€ãŸã‚ã®æº–å‚™
          if (shelterCards.isNotEmpty) {
            // ç¾åœ¨ã®ä½ç½®æƒ…å ±ã‚’å–å¾—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
            final currentLocation = ref.read(deviceStatusProvider).currentLocation;
            
            // é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™
            final shelterData = {
              'shelters': shelterCards,
              'userLocation': currentLocation != null
                  ? {
                      'latitude': currentLocation.latitude,
                      'longitude': currentLocation.longitude,
                    }
                  : null,
            };
            
            // ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªIDã‚’ç”Ÿæˆã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
            final shelterMapId = 'shelter_map_${agentMessageId}';
            final updatedCache = {...state.shelterDataCache};
            updatedCache[shelterMapId] = shelterData;
            
            // çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä¿å­˜
            state = state.copyWith(shelterDataCache: updatedCache);
            
            // ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸IDã¨é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿IDã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä¿å­˜
            final updatedMapping = {...state.chatIdToShelterDataId};
            updatedMapping[agentMessageId] = shelterMapId;
            state = state.copyWith(chatIdToShelterDataId: updatedMapping);
            
            // é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ã‚’æ°¸ç¶šåŒ–
            _saveTimeline();
          }
          
          // ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã®ã‚¿ã‚¤ãƒ—ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆæ–°æ—§ä¸¡æ–¹ã®å½¢å¼ã«å¯¾å¿œï¼‰
          final hazardMapCards = generatedCards
              .where((card) => card['card_type'] == 'hazard_map_info' || card['card_type'] == 'hazard_map_viewer')
              .toList();

          // ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã®å‡¦ç†
          if (hazardMapCards.isNotEmpty) {
            for (final hazardCard in hazardMapCards) {
              
              // æ–°ã—ã„action_buttonså½¢å¼ã‹ãƒã‚§ãƒƒã‚¯
              final actionButtons = hazardCard['action_buttons'] as List<dynamic>?;
              
              if (actionButtons != null && actionButtons.isNotEmpty) {
                // æ–°ã—ã„å½¢å¼: action_buttonsé…åˆ—ã‹ã‚‰è¤‡æ•°ã®ãƒœã‚¿ãƒ³ã‚’ç”Ÿæˆ
                for (int i = 0; i < actionButtons.length; i++) {
                  final button = actionButtons[i] as Map<String, dynamic>;
                  final hazardMapId =
                      'hazard_map_${DateTime.now().millisecondsSinceEpoch}_${hazardCard['card_id']}_$i';
                  
                  final hazardMapCard = TimelineItemModel.suggestion(
                    id: hazardMapId,
                    suggestionType: 'hazard_map_url',
                    content: hazardCard['title'] ?? 'ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—',
                    actionData: {
                      'action': 'open_hazard_map',
                      'url': button['url'],
                      'title': button['label'] ?? hazardCard['title'],
                      'description': hazardCard['description'],
                    },
                    actionQuery: null,
                    actionDisplayText: button['label'] ?? 'ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã‚’é–‹ã',
                    timestamp: DateTime.now(),
                  );

                  updatedItems.add(hazardMapCard);
                }
              } else {
                // æ—§å½¢å¼: å˜ä¸€ã®action_url
                final hazardMapId =
                    'hazard_map_${DateTime.now().millisecondsSinceEpoch}_${hazardCard['card_id']}';
                final hazardMapCard = TimelineItemModel.suggestion(
                  id: hazardMapId,
                  suggestionType: 'hazard_map_url',
                  content: hazardCard['title'] ?? 'ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—',
                  actionData: {
                    'action': 'open_hazard_map',
                    'url': hazardCard['action_url'],
                    'title': hazardCard['title'],
                    'description': hazardCard['description'],
                  },
                  actionQuery: null,
                  actionDisplayText: 'ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã‚’é–‹ã',
                  timestamp: DateTime.now(),
                );

                updatedItems.add(hazardMapCard);
              }
            }
          }
          
      // debugPrint('[TimelineProvider] === END GENERATED CARDS PROCESSING (ACTION QUERY) ===');
        }

        // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ
        final agentMessage = TimelineItemModel.chat(
          id: agentMessageId,
          timestamp: DateTime.now(),
          messageText: finalMessageText,
          senderNickname: 'SafetyBee',
          isOwnMessage: false,
        );
        
        // æœ€å¾Œã«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
        updatedItems.add(agentMessage);

        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‹•ä½œãŒæ—¢ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€å†è¨­å®šã™ã‚‹
        final currentScrollBehavior = state.scrollBehavior == TimelineScrollBehavior.none 
            ? TimelineScrollBehavior.toResponse 
            : state.scrollBehavior;
        
        state = state.copyWith(
          timelineItems: updatedItems,
          isChatLoading: false, // ãƒãƒ£ãƒƒãƒˆãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çµ‚äº†
          targetResponseId: agentMessageId, // ç”Ÿæˆã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸IDã‚’ç¢ºå®Ÿã«è¨­å®š
          scrollBehavior: currentScrollBehavior, // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‹•ä½œã‚’ç¶­æŒã¾ãŸã¯å†è¨­å®š
        );
        
        // ãƒãƒ£ãƒƒãƒˆå®Œäº†ã‚’DeviceStatusProviderã«é€šçŸ¥
        if (!_isDisposed) {
          ref.read(deviceStatusProvider.notifier).endChatSession();
        }
      } else {
        // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒãªã„å ´åˆã‚‚ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çµ‚äº†
        if (!_isDisposed) {
          state = state.copyWith(
            isChatLoading: false,
            scrollBehavior: TimelineScrollBehavior.none,
            targetResponseId: null,
          );
        }
        
        // ãƒãƒ£ãƒƒãƒˆå®Œäº†ã‚’DeviceStatusProviderã«é€šçŸ¥ï¼ˆãƒ¬ã‚¹ãƒãƒ³ã‚¹ãªã—æ™‚ï¼‰
        if (!_isDisposed) {
          ref.read(deviceStatusProvider.notifier).endChatSession();
        }
      }
    } catch (e) {
      // debugPrint('Failed to send action query: $e');

      // ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ãŒã¾ã æœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
      if (_isDisposed) {
      // debugPrint('Provider disposed during action query, skipping state update');
        return;
      }

      // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤ã—ã¦ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çµ‚äº†
      state = state.copyWith(
        timelineItems: state.timelineItems
            .where((item) => item.id != userMessageId)
            .toList(),
        isChatLoading: false,
        scrollBehavior: TimelineScrollBehavior.none,
        targetResponseId: null,
      );
      
      // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚’ä¿å­˜
      _saveTimeline();
      
      // ãƒãƒ£ãƒƒãƒˆå®Œäº†ã‚’DeviceStatusProviderã«é€šçŸ¥ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ï¼‰
      try {
        if (!_isDisposed) {
          ref.read(deviceStatusProvider.notifier).endChatSession();
        }
      } catch (endSessionError) {
      // debugPrint('Error ending chat session: $endSessionError');
      }
    }
  }

  /// ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤
  void removeTimelineItem(String itemId) {
    // ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’å‡ºåŠ›ã—ã¦ã©ã“ã‹ã‚‰å‘¼ã°ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
      // debugPrint('[TimelineProvider] removeTimelineItem called for: $itemId');
      // debugPrint('[TimelineProvider] Stack trace:');
    try {
      throw Exception('Stack trace');
    } catch (e, stackTrace) {
      // debugPrint(stackTrace.toString().split('\n').take(15).join('\n'));
    }
    
    final updatedItems = state.timelineItems
        .where((item) => item.id != itemId)
        .toList();
    state = state.copyWith(timelineItems: updatedItems);
      // debugPrint('[TimelineProvider] Removed timeline item: $itemId');
    
    // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚’ä¿å­˜ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãªã®ã§å³åº§ã«ä¿å­˜ï¼‰
    _saveTimelineImmediate();
  }

  /// ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ID ã«é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ã‚’é–¢é€£ä»˜ã‘ã‚‹
  void setShelterDataForChat(String chatId, List<dynamic> shelterData) {
    if (shelterData.isEmpty) return;
    
    final shelterDataId = 'shelter_${DateTime.now().millisecondsSinceEpoch}';
    
    // é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
    final newShelterDataCache = Map<String, Map<String, dynamic>>.from(state.shelterDataCache);
    newShelterDataCache[shelterDataId] = {
      'shelters': shelterData,
      'timestamp': DateTime.now().toIso8601String(),
    };
    
    // ãƒãƒ£ãƒƒãƒˆIDã‹ã‚‰é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿IDã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä¿å­˜
    final newChatToShelterMapping = Map<String, String>.from(state.chatIdToShelterDataId);
    newChatToShelterMapping[chatId] = shelterDataId;
    
    state = state.copyWith(
      shelterDataCache: newShelterDataCache,
      chatIdToShelterDataId: newChatToShelterMapping,
    );
    
    if (kDebugMode) {
      debugPrint('[TimelineProvider] Set shelter data for chat $chatId: ${shelterData.length} shelters');
    }
    
    // é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ã‚‚æ°¸ç¶šåŒ–
    _saveTimeline();
  }


  /// å®Œå…¨ãƒªã‚»ãƒƒãƒˆ - å…¨ã¦ã®ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¯ãƒªã‚¢ï¼ˆè¨­å®šãƒªã‚»ãƒƒãƒˆæ™‚ä½¿ç”¨ï¼‰
  void clearAllTimelineItems() {
      // debugPrint('[TimelineProvider] === CLEARING ALL TIMELINE ITEMS ===');
      // debugPrint('[TimelineProvider] Current items count: ${state.timelineItems.length}');
    
    // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚’åœæ­¢
    stopStreaming();
    
    // å…¨ã¦ã®ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¯ãƒªã‚¢
    final previousCount = state.timelineItems.length;
    state = state.copyWith(
      timelineItems: [],
      errorMessage: null,
      importantAlert: null,
      streamedSuggestions: [],
    );
    
    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚‚åŒæœŸã—ã¦ã‚¯ãƒªã‚¢ï¼ˆè¨­å®šãƒªã‚»ãƒƒãƒˆæ™‚ã¯å³åº§ã«ä¿å­˜ï¼‰
    _saveTimelineImmediate();
    
      // debugPrint('[TimelineProvider] âš ï¸ TIMELINE CLEARED: $previousCount items removed');
  }

  /// ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°æ©Ÿèƒ½ã®æœ‰åŠ¹/ç„¡åŠ¹ã‚’åˆ‡ã‚Šæ›¿ãˆ
  void toggleStreamingMode() {
    final newStreamingEnabled = !state.isStreamingEnabled;
    
    state = state.copyWith(isStreamingEnabled: newStreamingEnabled);
    
    if (!newStreamingEnabled) {
      // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ç„¡åŠ¹æ™‚ã¯åœæ­¢
      stopStreaming();
    }
  }

  /// ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ææ¡ˆå–å¾—ã‚’é–‹å§‹ï¼ˆç„¡åŠ¹åŒ–æ¸ˆã¿ï¼‰
  Future<void> startStreaming() async {
    return; // ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆçµ±åˆã«ã‚ˆã‚Šç„¡åŠ¹åŒ–
  }



  /// ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚’åœæ­¢
  void stopStreaming() {
    _streamSubscription?.cancel();
    _streamSubscription = null;
    state = state.copyWith(isStreaming: false);
  }


  /// ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’ TimelineItemModel ã«å¤‰æ›
  TimelineItemModel? _parseStreamedSuggestion(Map<String, dynamic> data) {
    try {
      final suggestionData = data['data'] ?? data;
      
      if (suggestionData['type'] == null) {
        return null;
      }

      final type = suggestionData['type'] as String;
      final id = '${type}_streamed_${DateTime.now().millisecondsSinceEpoch}';

      // ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ææ¡ˆã‚¿ã‚¤ãƒ—ã‚’ãƒã‚§ãƒƒã‚¯
      const supportedTypes = {
        'welcome_message',
        'contact_registration_prompt',
        'contact_registration_reminder',
        'guide_recommendation',
        'app_feature_introduction',
        'hazard_map_prompt',
        'emergency_contact_setup',
        'low_battery_warning',
        // 'emergency_alert', // FCMã‹ã‚‰ã®ã¿å‡¦ç†
        // 'disaster_update', // FCMã‹ã‚‰ã®ã¿å‡¦ç†
        'disaster_news', // æƒ…å ±æä¾›ã®ã¿ï¼ˆã‚¢ãƒ©ãƒ¼ãƒˆã§ã¯ãªã„ï¼‰
        'quiz_reminder',
        'safety_confirmation_sms_proposal',
        'immediate_safety_action',
        'evacuation_prompt',
        'official_info_check_prompt',
        'seasonal_warning',
        'emergency',
        // 'emergency_disaster_news', // FCMã‹ã‚‰ã®ã¿å‡¦ç†
        'emergency_guidance',
        'disaster_info', // æƒ…å ±æä¾›ã®ã¿ï¼ˆã‚¢ãƒ©ãƒ¼ãƒˆã§ã¯ãªã„ï¼‰
        'evacuation_instruction',
        'location_based_info',
        'seasonal_alert',
        'app_feature_recommendation',
        'shelter_status_update',
        'shelter_info',
      };

      if (!supportedTypes.contains(type)) {
      // debugPrint('[TimelineProvider] Unsupported streamed suggestion type: $type');
        return null;
      }

      return TimelineItemModel.suggestion(
        id: id,
        suggestionType: type,
        content: suggestionData['content'] ?? '',
        actionData: suggestionData['action_data'],
        actionQuery: suggestionData['action_query'],
        actionDisplayText: suggestionData['action_display_text'],
        timestamp: DateTime.parse(
          suggestionData['created_at'] ?? DateTime.now().toIso8601String(),
        ),
      );
    } catch (e) {
      // debugPrint('[TimelineProvider] Failed to parse streamed suggestion: $e');
      return null;
    }
  }

  /// ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ææ¡ˆã‚’ãƒ¡ã‚¤ãƒ³ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã«çµ±åˆ
  void integrateStreamedSuggestions() {
    if (state.streamedSuggestions.isEmpty) return;

      // debugPrint('[TimelineProvider] Integrating ${state.streamedSuggestions.length} streamed suggestions');
    
    // æ—¢å­˜ã®ææ¡ˆã‚’å–å¾—ï¼ˆå†…å®¹ãƒ™ãƒ¼ã‚¹ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨ï¼‰
    final existingSuggestions = state.timelineItems
        .where((item) => item.type == TimelineItemType.suggestion)
        .map((item) => item.when(
              alert: (_, __, ___, ____, _____) => null,
              chat: (_, __, ___, ____, _____) => null,
              chatWithAction: (_, __, ___, ____, _____, ______, _______) => null,
              suggestion: (id, suggestionType, timestamp, content, _____, ______, _______) => {
                'id': id,
                'type': suggestionType,
                'content': content,
                'timestamp': timestamp.toIso8601String(),
              },
            ))
        .where((item) => item != null)
        .cast<Map<String, String>>()
        .toList();

    final newSuggestions = state.streamedSuggestions.where((suggestion) {
      return suggestion.when(
        alert: (_, __, ___, ____, _____) => true,
        chat: (_, __, ___, ____, _____) => true,
        chatWithAction: (_, __, ___, ____, _____, ______, _______) => true,
        suggestion: (_, suggestionType, ___, content, ____, _____, ______) {
          return !_isDuplicateSuggestion(suggestionType, content, existingSuggestions);
        },
      );
    }).toList();

    if (newSuggestions.isNotEmpty) {
      state = state.copyWith(
        timelineItems: [...state.timelineItems, ...newSuggestions],
        streamedSuggestions: [], // ã‚¯ãƒªã‚¢
      );
      
      _saveTimeline();
      // debugPrint('[TimelineProvider] Integrated ${newSuggestions.length} new suggestions');
    } else {
      // debugPrint('[TimelineProvider] No new suggestions to integrate (all duplicates)');
      state = state.copyWith(streamedSuggestions: []);
    }
  }

  /// ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ææ¡ˆã‚’ã‚¯ãƒªã‚¢
  void clearStreamedSuggestions() {
    state = state.copyWith(streamedSuggestions: []);
  }

  /// ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆçµ±åˆSSEæ¥ç¶šã‚’ãƒˆãƒªã‚¬ãƒ¼
  Future<void> triggerSSEConnection() async {
      // debugPrint('[TimelineProvider] ğŸš€ Triggering SSE connection from heartbeat');
    
    try {
      // SSEæ©Ÿèƒ½ã¯ç¾åœ¨StreamingSuggestionsListã§ç®¡ç†ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€
      // ãã“ã«SSEé–‹å§‹ã‚’é€šçŸ¥ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
      // 
      // æ³¨æ„: ã“ã®å®Ÿè£…ã¯StreamingSuggestionsListã«ä¾å­˜ã—ã¦ã„ã‚‹ãŸã‚ã€
      // ã‚ˆã‚Šè‰¯ã„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã€StreamingSuggestionsListãŒTimelineProviderã®
      // çŠ¶æ…‹å¤‰æ›´ã‚’ç›£è¦–ã™ã‚‹ã“ã¨ã§ã™
      
      // çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¦SSEé–‹å§‹ã‚’ç¤ºã™
      state = state.copyWith(isStreaming: true);
      // debugPrint('[TimelineProvider] âœ… SSE trigger state updated');
      
      // SSEæ¥ç¶šé–‹å§‹å¾Œã€StreamingSuggestionsListãŒå‡¦ç†ã‚’é–‹å§‹ã—ãŸã‚‰
      // 3ç§’å¾Œã«è‡ªå‹•çš„ã«ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆè¤‡æ•°å›ã®ãƒˆãƒªã‚¬ãƒ¼ã‚’é˜²ããŸã‚ï¼‰
      // 1ç§’ã§ã¯çŸ­ã™ãã¦SSEæ¥ç¶šãŒé–‹å§‹ã•ã‚Œã‚‹å‰ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
      Future.delayed(const Duration(seconds: 3), () {
        if (state.isStreaming) {
          state = state.copyWith(isStreaming: false);
      // debugPrint('[TimelineProvider] ğŸ”„ SSE trigger state reset after delay');
        }
      });
      
    } catch (e) {
      // debugPrint('[TimelineProvider] âŒ Failed to trigger SSE connection: $e');
    }
  }

  /// ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ãŒç ´æ£„ã•ã‚Œã‚‹éš›ã®æ¸…æƒ
  void dispose() {
    _isDisposed = true;
    stopStreaming();
    _saveDebounceTimer?.cancel();
  }

  /// é‡è¤‡ææ¡ˆãƒã‚§ãƒƒã‚¯
  bool _isDuplicateSuggestion(String suggestionType, String content, List<Map<String, String>> existingSuggestions) {
    // ã™ã§ã«åŒã˜ã‚¿ã‚¤ãƒ—ã®ææ¡ˆãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯é‡è¤‡ã¨åˆ¤å®š
    final isDuplicate = existingSuggestions.any((existing) => existing['type'] == suggestionType);
    
    if (isDuplicate) {
      // debugPrint('[TimelineProvider] ğŸš« Duplicate suggestion filtered: $suggestionType already exists in timeline');
    }
    
    return isDuplicate;
  }

  /// Add a chat message to the timeline (used by voice chat)
  void addMessage(ChatMessage message) {
      // debugPrint('[TimelineProvider] Adding chat message from voice input');
    
    // Convert ChatMessage to TimelineItemModel
    final timelineItem = TimelineItemModel.chat(
      id: message.id,
      timestamp: message.timestamp,
      messageText: message.content,
      senderNickname: message.sender == MessageSender.user ? 'You' : 
                      message.sender == MessageSender.ai ? 'SafetyBee' : 'System',
      isOwnMessage: message.sender == MessageSender.user,
    );
    
    // Add to timeline
    state = state.copyWith(
      timelineItems: [...state.timelineItems, timelineItem],
    );
    
    // Save timelineï¼ˆéŸ³å£°ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯å³åº§ã«ä¿å­˜ï¼‰
    _saveTimelineImmediate();
    
    // Process any cards that came with the response
    final cards = message.metadata?['cards'] as List<dynamic>?;
    if (cards != null && cards.isNotEmpty) {
      _processGeneratedCards(cards, message.id);
    }
  }

  /// Process generated cards from chat response
  void _processGeneratedCards(List<dynamic> generatedCards, String messageId) {
    if (generatedCards.isEmpty) return;
    
      // debugPrint('[TimelineProvider] Processing ${generatedCards.length} generated cards from voice chat');
    
    // Current timeline items
    List<TimelineItemModel> updatedItems = [...state.timelineItems];
    
    // Filter shelter cards
    final shelterCards = generatedCards.where((card) {
      final isEvacuationType = 
        card['type'] == 'shelter_status_update' ||
        card['card_type'] == 'evacuation_info' ||
        card['type'] == 'shelter_location' ||
        card['type'] == 'shelter_info';
      
      if (!isEvacuationType) return false;
      
      final location = card['location'] as Map<String, dynamic>?;
      final data = card['data'] as Map<String, dynamic>?;
      
      final hasLatitude = location?['latitude'] != null || 
                         data?['latitude'] != null ||
                         card['shelter_latitude'] != null;
      final hasLongitude = location?['longitude'] != null || 
                           data?['longitude'] != null ||
                           card['shelter_longitude'] != null;
      
      return hasLatitude && hasLongitude;
    }).toList();
    
    // Process shelter cards
    if (shelterCards.isNotEmpty) {
      // Use cached location instead of fetching new location
      final currentLocation = ref.read(deviceStatusProvider).currentLocation;
      final shelterData = {
        'shelters': shelterCards,
        'userLocation': currentLocation != null
            ? {
                'latitude': currentLocation.latitude,
                'longitude': currentLocation.longitude,
              }
            : null,
      };
      
      final shelterMapId = 'shelter_map_${messageId}';
      final updatedCache = {...state.shelterDataCache};
      updatedCache[shelterMapId] = shelterData;
      
      state = state.copyWith(shelterDataCache: updatedCache);
      
      final updatedMapping = {...state.chatIdToShelterDataId};
      updatedMapping[messageId] = shelterMapId;
      state = state.copyWith(chatIdToShelterDataId: updatedMapping);
      
      _saveTimelineImmediate();
    }
    
    // Process hazard map cards
    final hazardMapCards = generatedCards
        .where((card) => card['card_type'] == 'hazard_map_info' || card['card_type'] == 'hazard_map_viewer')
        .toList();
    
    if (hazardMapCards.isNotEmpty) {
      for (final hazardCard in hazardMapCards) {
        final actionButtons = hazardCard['action_buttons'] as List<dynamic>?;
        
        if (actionButtons != null && actionButtons.isNotEmpty) {
          for (int i = 0; i < actionButtons.length; i++) {
            final button = actionButtons[i] as Map<String, dynamic>;
            final hazardMapId = 'hazard_map_${DateTime.now().millisecondsSinceEpoch}_${hazardCard['card_id']}_$i';
            
            final hazardMapItem = TimelineItemModel.suggestion(
              id: hazardMapId,
              suggestionType: 'hazard_map_url',
              content: hazardCard['title'] ?? 'ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—',
              actionData: {
                'action': 'open_hazard_map',
                'url': button['url'],
                'title': button['label'] ?? hazardCard['title'],
                'description': hazardCard['description'],
              },
              actionQuery: null,
              actionDisplayText: button['label'] ?? 'ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã‚’é–‹ã',
              timestamp: DateTime.now(),
            );
            
            updatedItems.add(hazardMapItem);
          }
        } else {
          final hazardMapId = 'hazard_map_${DateTime.now().millisecondsSinceEpoch}_${hazardCard['card_id']}';
          final hazardMapItem = TimelineItemModel.suggestion(
            id: hazardMapId,
            suggestionType: 'hazard_map_url',
            content: hazardCard['title'] ?? 'ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—',
            actionData: {
              'action': 'open_hazard_map',
              'url': hazardCard['action_url'],
              'title': hazardCard['title'],
              'description': hazardCard['description'],
            },
            actionQuery: null,
            actionDisplayText: 'ãƒã‚¶ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã‚’é–‹ã',
            timestamp: DateTime.now(),
          );
          
          updatedItems.add(hazardMapItem);
        }
      }
    }
    
    // Update state with new items
    if (updatedItems.length > state.timelineItems.length) {
      state = state.copyWith(timelineItems: updatedItems);
      _saveTimelineImmediate();
    }
  }

  /// å†…å®¹ã®é¡ä¼¼åº¦ãƒã‚§ãƒƒã‚¯
  bool _isSimilarContent(String existing, String newContent) {
    // ç©ºæ–‡å­—åˆ—ã®å ´åˆã¯ã‚¿ã‚¤ãƒ—ã®ã¿ã§åˆ¤å®š
    if (existing.isEmpty || newContent.isEmpty) {
      return existing == newContent;
    }

    // å®Œå…¨ä¸€è‡´ã®å ´åˆã¯é‡è¤‡
    if (existing == newContent) {
      return true;
    }

    // é•·ã•ãŒå¤§ããç•°ãªã‚‹å ´åˆã¯åˆ¥ã®å†…å®¹ã¨åˆ¤å®š
    if ((existing.length - newContent.length).abs() > existing.length * 0.5) {
      return false;
    }

    // å˜èªãƒ™ãƒ¼ã‚¹ã®é¡ä¼¼åº¦ãƒã‚§ãƒƒã‚¯ï¼ˆç°¡æ˜“ç‰ˆï¼‰
    final existingWords = existing.toLowerCase().split(RegExp(r'[\s\p{P}]+'));
    final newWords = newContent.toLowerCase().split(RegExp(r'[\s\p{P}]+'));
    
    // å…±é€šå˜èªã®å‰²åˆã‚’è¨ˆç®—
    final commonWords = existingWords.where((word) => newWords.contains(word)).length;
    final maxWords = [existingWords.length, newWords.length].reduce((a, b) => a > b ? a : b);
    
    // 70%ä»¥ä¸Šã®å˜èªãŒå…±é€šã—ã¦ã„ã‚‹å ´åˆã¯é¡ä¼¼ã¨åˆ¤å®š
    return maxWords > 0 && (commonWords / maxWords) >= 0.7;
  }

  /// ã‚¢ãƒ©ãƒ¼ãƒˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚º
  Map<String, String> _getLocalizedAlertContent(String alertType, String languageCode) {
    // ã‚¢ãƒ©ãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã«åŸºã¥ã„ã¦ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºã•ã‚ŒãŸã‚¿ã‚¤ãƒˆãƒ«ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™
    final localizedContent = <String, String>{};
    
    switch (alertType) {
      case 'earthquake':
        localizedContent['title'] = _getLocalizedAlertTitle('earthquake', languageCode);
        localizedContent['message'] = _getLocalizedAlertMessage('earthquake', languageCode);
        break;
      case 'tsunami':
        localizedContent['title'] = _getLocalizedAlertTitle('tsunami', languageCode);
        localizedContent['message'] = _getLocalizedAlertMessage('tsunami', languageCode);
        break;
      case 'heavy_rain':
        localizedContent['title'] = _getLocalizedAlertTitle('heavy_rain', languageCode);
        localizedContent['message'] = _getLocalizedAlertMessage('heavy_rain', languageCode);
        break;
      case 'fire':
        localizedContent['title'] = _getLocalizedAlertTitle('fire', languageCode);
        localizedContent['message'] = _getLocalizedAlertMessage('fire', languageCode);
        break;
      default:
        localizedContent['title'] = _getLocalizedAlertTitle('emergency', languageCode);
        localizedContent['message'] = _getLocalizedAlertMessage('emergency', languageCode);
        break;
    }
    
    return localizedContent;
  }

  String _getLocalizedAlertTitle(String alertType, String languageCode) {
    // ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºã•ã‚ŒãŸã‚¿ã‚¤ãƒˆãƒ«ã‚’è¿”ã™
    final titles = {
      'earthquake': {
        'ja': 'ğŸš¨ ç·Šæ€¥åœ°éœ‡é€Ÿå ±ï¼ˆãƒ†ã‚¹ãƒˆï¼‰',
        'en': 'ğŸš¨ Earthquake Alert (Test)',
        'zh': 'ğŸš¨ ç´§æ€¥åœ°éœ‡é€ŸæŠ¥ï¼ˆæµ‹è¯•ï¼‰',
        'zh_CN': 'ğŸš¨ ç´§æ€¥åœ°éœ‡é€ŸæŠ¥ï¼ˆæµ‹è¯•ï¼‰',
        'zh_TW': 'ğŸš¨ ç·Šæ€¥åœ°éœ‡é€Ÿå ±ï¼ˆæ¸¬è©¦ï¼‰',
        'ko': 'ğŸš¨ ê¸´ê¸‰ ì§€ì§„ ì†ë³´ (í…ŒìŠ¤íŠ¸)',
        'es': 'ğŸš¨ Alerta de Terremoto (Prueba)',
        'fr': 'ğŸš¨ Alerte SÃ©isme (Test)',
        'de': 'ğŸš¨ Erdbebenwarnung (Test)',
        'it': 'ğŸš¨ Allerta Terremoto (Test)',
        'pt': 'ğŸš¨ Alerta de Terremoto (Teste)',
        'ru': 'ğŸš¨ Ğ­ĞºÑÑ‚Ñ€ĞµĞ½Ğ½Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ·ĞµĞ¼Ğ»ĞµÑ‚Ñ€ÑÑĞµĞ½Ğ¸Ğ¸ (Ğ¢ĞµÑÑ‚)',
      },
      'tsunami': {
        'ja': 'ğŸŒŠ æ´¥æ³¢è­¦å ±ï¼ˆãƒ†ã‚¹ãƒˆï¼‰',
        'en': 'ğŸŒŠ Tsunami Warning (Test)',
        'zh': 'ğŸŒŠ æµ·å•¸è­¦æŠ¥ï¼ˆæµ‹è¯•ï¼‰',
        'zh_CN': 'ğŸŒŠ æµ·å•¸è­¦æŠ¥ï¼ˆæµ‹è¯•ï¼‰',
        'zh_TW': 'ğŸŒŠ æµ·å˜¯è­¦å ±ï¼ˆæ¸¬è©¦ï¼‰',
        'ko': 'ğŸŒŠ ì“°ë‚˜ë¯¸ ê²½ë³´ (í…ŒìŠ¤íŠ¸)',
        'es': 'ğŸŒŠ Alerta de Tsunami (Prueba)',
        'fr': 'ğŸŒŠ Alerte Tsunami (Test)',
        'de': 'ğŸŒŠ Tsunami-Warnung (Test)',
        'it': 'ğŸŒŠ Allerta Tsunami (Test)',
        'pt': 'ğŸŒŠ Alerta de Tsunami (Teste)',
        'ru': 'ğŸŒŠ ĞŸÑ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾ Ñ†ÑƒĞ½Ğ°Ğ¼Ğ¸ (Ğ¢ĞµÑÑ‚)',
      },
      'heavy_rain': {
        'ja': 'ğŸŒ§ï¸ å¤§é›¨ç‰¹åˆ¥è­¦å ±ï¼ˆãƒ†ã‚¹ãƒˆï¼‰',
        'en': 'ğŸŒ§ï¸ Heavy Rain Warning (Test)',
        'zh': 'ğŸŒ§ï¸ æš´é›¨ç‰¹åˆ«è­¦æŠ¥ï¼ˆæµ‹è¯•ï¼‰',
        'zh_CN': 'ğŸŒ§ï¸ æš´é›¨ç‰¹åˆ«è­¦æŠ¥ï¼ˆæµ‹è¯•ï¼‰',
        'zh_TW': 'ğŸŒ§ï¸ å¤§é›¨ç‰¹åˆ¥è­¦å ±ï¼ˆæ¸¬è©¦ï¼‰',
        'ko': 'ğŸŒ§ï¸ í˜¸ìš° íŠ¹ë³´ (í…ŒìŠ¤íŠ¸)',
        'es': 'ğŸŒ§ï¸ Alerta de Lluvia Intensa (Prueba)',
        'fr': 'ğŸŒ§ï¸ Alerte Fortes Pluies (Test)',
        'de': 'ğŸŒ§ï¸ Starkregenwarnung (Test)',
        'it': 'ğŸŒ§ï¸ Allerta Pioggia Intensa (Test)',
        'pt': 'ğŸŒ§ï¸ Alerta de Chuva Forte (Teste)',
        'ru': 'ğŸŒ§ï¸ ĞŸÑ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾ ÑĞ¸Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ´Ğ¾Ğ¶Ğ´Ğµ (Ğ¢ĞµÑÑ‚)',
      },
      'fire': {
        'ja': 'ğŸ”¥ ç«ç½è­¦å ±ï¼ˆãƒ†ã‚¹ãƒˆï¼‰',
        'en': 'ğŸ”¥ Fire Alert (Test)',
        'zh': 'ğŸ”¥ ç«ç¾è­¦æŠ¥ï¼ˆæµ‹è¯•ï¼‰',
        'zh_CN': 'ğŸ”¥ ç«ç¾è­¦æŠ¥ï¼ˆæµ‹è¯•ï¼‰',
        'zh_TW': 'ğŸ”¥ ç«ç½è­¦å ±ï¼ˆæ¸¬è©¦ï¼‰',
        'ko': 'ğŸ”¥ í™”ì¬ ê²½ë³´ (í…ŒìŠ¤íŠ¸)',
        'es': 'ğŸ”¥ Alerta de Incendio (Prueba)',
        'fr': 'ğŸ”¥ Alerte Incendie (Test)',
        'de': 'ğŸ”¥ Feueralarm (Test)',
        'it': 'ğŸ”¥ Allerta Incendio (Test)',
        'pt': 'ğŸ”¥ Alerta de IncÃªndio (Teste)',
        'ru': 'ğŸ”¥ ĞŸĞ¾Ğ¶Ğ°Ñ€Ğ½Ğ°Ñ Ñ‚Ñ€ĞµĞ²Ğ¾Ğ³Ğ° (Ğ¢ĞµÑÑ‚)',
      },
      'emergency': {
        'ja': 'ğŸš¨ ç·Šæ€¥ã‚¢ãƒ©ãƒ¼ãƒˆï¼ˆãƒ†ã‚¹ãƒˆï¼‰',
        'en': 'ğŸš¨ Emergency Alert (Test)',
        'zh': 'ğŸš¨ ç´§æ€¥è­¦æŠ¥ï¼ˆæµ‹è¯•ï¼‰',
        'zh_CN': 'ğŸš¨ ç´§æ€¥è­¦æŠ¥ï¼ˆæµ‹è¯•ï¼‰',
        'zh_TW': 'ğŸš¨ ç·Šæ€¥è­¦å ±ï¼ˆæ¸¬è©¦ï¼‰',
        'ko': 'ğŸš¨ ê¸´ê¸‰ ê²½ë³´ (í…ŒìŠ¤íŠ¸)',
        'es': 'ğŸš¨ Alerta de Emergencia (Prueba)',
        'fr': 'ğŸš¨ Alerte d\'Urgence (Test)',
        'de': 'ğŸš¨ Notfallwarnung (Test)',
        'it': 'ğŸš¨ Allerta di Emergenza (Test)',
        'pt': 'ğŸš¨ Alerta de EmergÃªncia (Teste)',
        'ru': 'ğŸš¨ Ğ­ĞºÑÑ‚Ñ€ĞµĞ½Ğ½Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ (Ğ¢ĞµÑÑ‚)',
      },
    };
    
    return titles[alertType]?[languageCode] ?? titles[alertType]?['ja'] ?? 'ğŸš¨ ç·Šæ€¥ã‚¢ãƒ©ãƒ¼ãƒˆï¼ˆãƒ†ã‚¹ãƒˆï¼‰';
  }

  String _getLocalizedAlertMessage(String alertType, String languageCode) {
    // ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚ºã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™
    final messages = {
      'earthquake': {
        'ja': 'ã“ã‚Œã¯ãƒ†ã‚¹ãƒˆç”¨ã®ç·Šæ€¥åœ°éœ‡é€Ÿå ±ã§ã™ã€‚å¼·ã„æºã‚Œã«è­¦æˆ’ã—ã¦ãã ã•ã„ã€‚ï¼ˆãƒ†ã‚¹ãƒˆï¼‰',
        'en': 'This is a test earthquake alert. Please take cover from strong shaking. (Test)',
        'zh': 'è¿™æ˜¯æµ‹è¯•ç”¨çš„ç´§æ€¥åœ°éœ‡é€ŸæŠ¥ã€‚è¯·è­¦æƒ•å¼ºçƒˆæ‘‡æ™ƒã€‚ï¼ˆæµ‹è¯•ï¼‰',
        'zh_CN': 'è¿™æ˜¯æµ‹è¯•ç”¨çš„ç´§æ€¥åœ°éœ‡é€ŸæŠ¥ã€‚è¯·è­¦æƒ•å¼ºçƒˆæ‘‡æ™ƒã€‚ï¼ˆæµ‹è¯•ï¼‰',
        'zh_TW': 'é€™æ˜¯æ¸¬è©¦ç”¨çš„ç·Šæ€¥åœ°éœ‡é€Ÿå ±ã€‚è«‹è­¦æƒ•å¼·çƒˆæ–æ™ƒã€‚ï¼ˆæ¸¬è©¦ï¼‰',
        'ko': 'ì´ê²ƒì€ í…ŒìŠ¤íŠ¸ìš© ê¸´ê¸‰ ì§€ì§„ ì†ë³´ì…ë‹ˆë‹¤. ê°•í•œ í”ë“¤ë¦¼ì— ì£¼ì˜í•˜ì„¸ìš”. (í…ŒìŠ¤íŠ¸)',
        'es': 'Esta es una alerta de terremoto de prueba. ProtÃ©jase de las sacudidas fuertes. (Prueba)',
        'fr': 'Ceci est une alerte sismique de test. Abritez-vous des fortes secousses. (Test)',
        'de': 'Dies ist eine Test-Erdbebenwarnung. SchÃ¼tzen Sie sich vor starken ErschÃ¼tterungen. (Test)',
        'it': 'Questo Ã¨ un test di allerta terremoto. Proteggersi dalle forti scosse. (Test)',
        'pt': 'Este Ã© um alerta de terremoto de teste. Proteja-se de tremores fortes. (Teste)',
        'ru': 'Ğ­Ñ‚Ğ¾ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ·ĞµĞ¼Ğ»ĞµÑ‚Ñ€ÑÑĞµĞ½Ğ¸Ğ¸. Ğ£ĞºÑ€Ğ¾Ğ¹Ñ‚ĞµÑÑŒ Ğ¾Ñ‚ ÑĞ¸Ğ»ÑŒĞ½Ñ‹Ñ… Ñ‚Ğ¾Ğ»Ñ‡ĞºĞ¾Ğ². (Ğ¢ĞµÑÑ‚)',
      },
      'tsunami': {
        'ja': 'ã“ã‚Œã¯ãƒ†ã‚¹ãƒˆç”¨ã®æ´¥æ³¢è­¦å ±ã§ã™ã€‚é«˜å°ã«é¿é›£ã—ã¦ãã ã•ã„ã€‚ï¼ˆãƒ†ã‚¹ãƒˆï¼‰',
        'en': 'This is a test tsunami warning. Please evacuate to higher ground. (Test)',
        'zh': 'è¿™æ˜¯æµ‹è¯•ç”¨çš„æµ·å•¸è­¦æŠ¥ã€‚è¯·é¿éš¾åˆ°é«˜åœ°ã€‚ï¼ˆæµ‹è¯•ï¼‰',
        'zh_CN': 'è¿™æ˜¯æµ‹è¯•ç”¨çš„æµ·å•¸è­¦æŠ¥ã€‚è¯·é¿éš¾åˆ°é«˜åœ°ã€‚ï¼ˆæµ‹è¯•ï¼‰',
        'zh_TW': 'é€™æ˜¯æ¸¬è©¦ç”¨çš„æµ·å˜¯è­¦å ±ã€‚è«‹é¿é›£åˆ°é«˜åœ°ã€‚ï¼ˆæ¸¬è©¦ï¼‰',
        'ko': 'ì´ê²ƒì€ í…ŒìŠ¤íŠ¸ìš© ì“°ë‚˜ë¯¸ ê²½ë³´ì…ë‹ˆë‹¤. ë†’ì€ ê³³ìœ¼ë¡œ ëŒ€í”¼í•˜ì„¸ìš”. (í…ŒìŠ¤íŠ¸)',
        'es': 'Esta es una alerta de tsunami de prueba. EvacÃºe a terrenos elevados. (Prueba)',
        'fr': 'Ceci est une alerte tsunami de test. Ã‰vacuez vers les hauteurs. (Test)',
        'de': 'Dies ist eine Test-Tsunami-Warnung. Evakuieren Sie auf hÃ¶her gelegenes GelÃ¤nde. (Test)',
        'it': 'Questo Ã¨ un test di allerta tsunami. Evacuare verso luoghi elevati. (Test)',
        'pt': 'Este Ã© um alerta de tsunami de teste. Evacue para terrenos elevados. (Teste)',
        'ru': 'Ğ­Ñ‚Ğ¾ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾ Ñ†ÑƒĞ½Ğ°Ğ¼Ğ¸. Ğ­Ğ²Ğ°ĞºÑƒĞ¸Ñ€ÑƒĞ¹Ñ‚ĞµÑÑŒ Ğ½Ğ° Ğ²Ğ¾Ğ·Ğ²Ñ‹ÑˆĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ. (Ğ¢ĞµÑÑ‚)',
      },
      'heavy_rain': {
        'ja': 'ã“ã‚Œã¯ãƒ†ã‚¹ãƒˆç”¨ã®å¤§é›¨ç‰¹åˆ¥è­¦å ±ã§ã™ã€‚å‘½ã‚’å®ˆã‚‹è¡Œå‹•ã‚’ã¨ã£ã¦ãã ã•ã„ã€‚ï¼ˆãƒ†ã‚¹ãƒˆï¼‰',
        'en': 'This is a test heavy rain warning. Please take life-saving actions. (Test)',
        'zh': 'è¿™æ˜¯æµ‹è¯•ç”¨çš„æš´é›¨ç‰¹åˆ«è­¦æŠ¥ã€‚è¯·é‡‡å–ä¿æŠ¤ç”Ÿå‘½çš„è¡ŒåŠ¨ã€‚ï¼ˆæµ‹è¯•ï¼‰',
        'zh_CN': 'è¿™æ˜¯æµ‹è¯•ç”¨çš„æš´é›¨ç‰¹åˆ«è­¦æŠ¥ã€‚è¯·é‡‡å–ä¿æŠ¤ç”Ÿå‘½çš„è¡ŒåŠ¨ã€‚ï¼ˆæµ‹è¯•ï¼‰',
        'zh_TW': 'é€™æ˜¯æ¸¬è©¦ç”¨çš„å¤§é›¨ç‰¹åˆ¥è­¦å ±ã€‚è«‹æ¡å–ä¿è­·ç”Ÿå‘½çš„è¡Œå‹•ã€‚ï¼ˆæ¸¬è©¦ï¼‰',
        'ko': 'ì´ê²ƒì€ í…ŒìŠ¤íŠ¸ìš© í˜¸ìš° íŠ¹ë³´ì…ë‹ˆë‹¤. ìƒëª…ì„ ì§€í‚¤ëŠ” í–‰ë™ì„ ì·¨í•˜ì„¸ìš”. (í…ŒìŠ¤íŠ¸)',
        'es': 'Esta es una alerta de lluvia intensa de prueba. Tome acciones para salvar su vida. (Prueba)',
        'fr': 'Ceci est une alerte de fortes pluies de test. Prenez des mesures pour sauver votre vie. (Test)',
        'de': 'Dies ist eine Test-Starkregenwarnung. Ergreifen Sie lebensrettende MaÃŸnahmen. (Test)',
        'it': 'Questo Ã¨ un test di allerta pioggia intensa. Prendere azioni salvavita. (Test)',
        'pt': 'Este Ã© um alerta de chuva forte de teste. Tome aÃ§Ãµes para salvar sua vida. (Teste)',
        'ru': 'Ğ­Ñ‚Ğ¾ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾ ÑĞ¸Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ´Ğ¾Ğ¶Ğ´Ğµ. ĞŸÑ€Ğ¸Ğ¼Ğ¸Ñ‚Ğµ Ğ¼ĞµÑ€Ñ‹ Ğ´Ğ»Ñ ÑĞ¿Ğ°ÑĞµĞ½Ğ¸Ñ Ğ¶Ğ¸Ğ·Ğ½Ğ¸. (Ğ¢ĞµÑÑ‚)',
      },
      'fire': {
        'ja': 'ã“ã‚Œã¯ãƒ†ã‚¹ãƒˆç”¨ã®ç«ç½è­¦å ±ã§ã™ã€‚é€Ÿã‚„ã‹ã«é¿é›£ã—ã¦ãã ã•ã„ã€‚ï¼ˆãƒ†ã‚¹ãƒˆï¼‰',
        'en': 'This is a test fire alert. Please evacuate immediately. (Test)',
        'zh': 'è¿™æ˜¯æµ‹è¯•ç”¨çš„ç«ç¾è­¦æŠ¥ã€‚è¯·è¿…é€Ÿé¿éš¾ã€‚ï¼ˆæµ‹è¯•ï¼‰',
        'zh_CN': 'è¿™æ˜¯æµ‹è¯•ç”¨çš„ç«ç¾è­¦æŠ¥ã€‚è¯·è¿…é€Ÿé¿éš¾ã€‚ï¼ˆæµ‹è¯•ï¼‰',
        'zh_TW': 'é€™æ˜¯æ¸¬è©¦ç”¨çš„ç«ç½è­¦å ±ã€‚è«‹è¿…é€Ÿé¿é›£ã€‚ï¼ˆæ¸¬è©¦ï¼‰',
        'ko': 'ì´ê²ƒì€ í…ŒìŠ¤íŠ¸ìš© í™”ì¬ ê²½ë³´ì…ë‹ˆë‹¤. ì‹ ì†íˆ ëŒ€í”¼í•˜ì„¸ìš”. (í…ŒìŠ¤íŠ¸)',
        'es': 'Esta es una alerta de incendio de prueba. EvacÃºe inmediatamente. (Prueba)',
        'fr': 'Ceci est une alerte incendie de test. Ã‰vacuez immÃ©diatement. (Test)',
        'de': 'Dies ist ein Test-Feueralarm. Evakuieren Sie sofort. (Test)',
        'it': 'Questo Ã¨ un test di allerta incendio. Evacuare immediatamente. (Test)',
        'pt': 'Este Ã© um alerta de incÃªndio de teste. Evacue imediatamente. (Teste)',
        'ru': 'Ğ­Ñ‚Ğ¾ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ°Ñ Ğ¿Ğ¾Ğ¶Ğ°Ñ€Ğ½Ğ°Ñ Ñ‚Ñ€ĞµĞ²Ğ¾Ğ³Ğ°. ĞĞµĞ¼ĞµĞ´Ğ»ĞµĞ½Ğ½Ğ¾ ÑĞ²Ğ°ĞºÑƒĞ¸Ñ€ÑƒĞ¹Ñ‚ĞµÑÑŒ. (Ğ¢ĞµÑÑ‚)',
      },
      'emergency': {
        'ja': 'ã“ã‚Œã¯ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ã‹ã‚‰ç™ºå ±ã•ã‚ŒãŸãƒ†ã‚¹ãƒˆã‚¢ãƒ©ãƒ¼ãƒˆã§ã™ã€‚',
        'en': 'This is a test alert triggered from debug features.',
        'zh': 'è¿™æ˜¯ä»è°ƒè¯•åŠŸèƒ½è§¦å‘çš„æµ‹è¯•è­¦æŠ¥ã€‚',
        'zh_CN': 'è¿™æ˜¯ä»è°ƒè¯•åŠŸèƒ½è§¦å‘çš„æµ‹è¯•è­¦æŠ¥ã€‚',
        'zh_TW': 'é€™æ˜¯å¾èª¿è©¦åŠŸèƒ½è§¸ç™¼çš„æ¸¬è©¦è­¦å ±ã€‚',
        'ko': 'ì´ê²ƒì€ ë””ë²„ê·¸ ê¸°ëŠ¥ì—ì„œ ë°œë ¹ëœ í…ŒìŠ¤íŠ¸ ê²½ë³´ì…ë‹ˆë‹¤.',
        'es': 'Esta es una alerta de prueba activada desde funciones de depuraciÃ³n.',
        'fr': 'Ceci est une alerte de test dÃ©clenchÃ©e depuis les fonctions de dÃ©bogage.',
        'de': 'Dies ist ein Testalarm, der von Debug-Funktionen ausgelÃ¶st wurde.',
        'it': 'Questo Ã¨ un avviso di test attivato dalle funzioni di debug.',
        'pt': 'Este Ã© um alerta de teste acionado a partir de recursos de depuraÃ§Ã£o.',
        'ru': 'Ğ­Ñ‚Ğ¾ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ, Ğ²Ñ‹Ğ·Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ Ğ¸Ğ· Ğ¾Ñ‚Ğ»Ğ°Ğ´Ğ¾Ñ‡Ğ½Ñ‹Ñ… Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¹.',
      },
    };
    
    return messages[alertType]?[languageCode] ?? messages[alertType]?['ja'] ?? 'ã“ã‚Œã¯ãƒ†ã‚¹ãƒˆã‚¢ãƒ©ãƒ¼ãƒˆã§ã™ã€‚';
  }

  /// ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‹•ä½œã‚’ãƒªã‚»ãƒƒãƒˆ
  void resetScrollBehavior() {
    state = state.copyWith(
      scrollBehavior: TimelineScrollBehavior.none,
      targetResponseId: null,
    );
  }

  /// é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ç”¨ï¼‰
  String _generateShelterDataHash(Map<String, dynamic> shelterData) {
    // é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ã®æœ¬è³ªçš„ãªå†…å®¹ã‹ã‚‰ãƒãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆ
    final shelters = shelterData['shelters'] as List<dynamic>? ?? [];
    final userLocation = shelterData['userLocation'] as Map<String, dynamic>?;
    
    // é¿é›£æ‰€IDã¨ä½ç½®æƒ…å ±ã‹ã‚‰ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¨ˆç®—
    final shelterIds = shelters.map((shelter) => 
      '${shelter['id'] ?? ''}_${shelter['name'] ?? ''}'
    ).join('|');
    
    final locationKey = userLocation != null 
      ? '${userLocation['latitude']}_${userLocation['longitude']}'
      : 'no_location';
    
    // æ–‡å­—åˆ—ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—
    final combined = '${shelterIds}_$locationKey';
    return combined.hashCode.abs().toString();
  }

  /// é¿é›£æ‰€ãƒ‡ãƒ¼ã‚¿ã‚’äº‹å‰å‡¦ç†ï¼ˆé‡è¤‡å‡¦ç†ã®å‰Šé™¤ï¼‰
  List<Map<String, dynamic>> _preprocessShelterData(List<dynamic> shelterCards) {
    return shelterCards.map((shelterData) {
      // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«å¯¾å¿œã—ãŸå¤‰æ›ï¼ˆçµ±ä¸€å‡¦ç†ï¼‰
      final locationData = shelterData['location'] as Map<String, dynamic>?;
      final dataField = shelterData['data'] as Map<String, dynamic>?;
      final latitude = locationData?['latitude'] as num? ?? 
                       dataField?['latitude'] as num? ??
                       shelterData['shelter_latitude'] as num?;
      final longitude = locationData?['longitude'] as num? ??
                        dataField?['longitude'] as num? ??
                        shelterData['shelter_longitude'] as num?;
      
      // çµ±ä¸€ã•ã‚ŒãŸãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§è¿”å´
      return {
        'id': shelterData['card_id'] ?? shelterData['id'] ?? 'unknown',
        'name': shelterData['title'] ?? shelterData['name'] ?? shelterData['shelter_name'] ?? 'Unknown Shelter',
        'status': dataField?['status'] ?? shelterData['status'] ?? 'Available',
        'latitude': latitude?.toDouble(),
        'longitude': longitude?.toDouble(),
        'address': shelterData['address'] ?? dataField?['address'] ?? shelterData['shelter_address'] ?? '',
        'shelter_type': dataField?['shelter_type'] ?? shelterData['shelter_type'] ?? '',
        'capacity': dataField?['capacity'] ?? shelterData['capacity'] ?? 0,
        'distance_km': dataField?['distance_km'] ?? shelterData['distance_km'] ?? 0.0,
      };
    }).toList();
  }

  /// ç·Šæ€¥é€£çµ¡å…ˆæ•°ã‚’å–å¾—
  Future<int> _getEmergencyContactsCount() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // ç·Šæ€¥é€£çµ¡å…ˆã®ã‚­ãƒ¼ã‚’ç¢ºèª
      final contactsStringList = prefs.getStringList('app_emergency_contacts_v2');
      
      if (contactsStringList == null || contactsStringList.isEmpty) {
        return 0;
      }
      
      return contactsStringList.length;
    } catch (e) {
      // debugPrint('[TimelineProvider] Error getting emergency contacts count: $e');
      return 0;
    }
  }

  /// ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢ï¼ˆSMSç¢ºèªãƒ•ã‚©ãƒ¼ãƒ ãªã©ï¼‰
  void clearItemAction(String itemId) {
    final updatedItems = state.timelineItems.map<TimelineItemModel>((item) {
      if (item.id == itemId && item is ChatWithActionTimelineItem) {
        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢ã—ãŸæ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä½œæˆ
        return TimelineItemModel.chat(
          id: item.id,
          timestamp: item.timestamp,
          messageText: item.messageText,
          senderNickname: item.senderNickname,
          isOwnMessage: item.isOwnMessage,
        );
      }
      return item;
    }).toList();

    state = state.copyWith(timelineItems: updatedItems);
    _saveTimeline(); // å¤‰æ›´ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
  }
  
  /// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã«åŸºã¥ã„ã¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¯ã‚¨ãƒªã‚’ç”Ÿæˆ
  String? _generateActionQuery(String? actionType) {
    if (actionType == null) return null;
    
    switch (actionType) {
      case 'check_disasters':
        return 'ç¾åœ¨ã®ç½å®³æƒ…å ±ã‚’æ•™ãˆã¦';
      case 'view_alerts':
        return 'ç½å®³è­¦å ±ã‚’ç¢ºèªã—ãŸã„';
      case 'find_shelters':
        return 'è¿‘ãã®é¿é›£æ‰€ã‚’æ•™ãˆã¦';
      case 'evacuation_guide':
        return 'é¿é›£ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹ã‚’çŸ¥ã‚ŠãŸã„';
      case 'disaster_info':
        return 'ç½å®³æƒ…å ±ã‚’æ•™ãˆã¦';
      case 'safety_guide':
        return 'é˜²ç½ã‚¬ã‚¤ãƒ‰ã‚’è¦‹ãŸã„';
      default:
        return 'è©³ç´°æƒ…å ±ã‚’æ•™ãˆã¦';
    }
  }
}
